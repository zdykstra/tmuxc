#!/bin/perl

use strict;
use warnings;

our $VERSION = '1.9.1';

use Getopt::Long qw(:config no_ignore_case auto_version);
use Time::HiRes  qw( sleep gettimeofday );
use POSIX        qw ( mkfifo setsid WNOHANG );
use FindBin      qw ($RealScript $RealBin);
use Sys::Syslog  qw(:standard :macros);
use Pod::Usage   qw(pod2usage);
use File::Basename;
use Sys::Hostname;
use IPC::Open2;
use Fcntl;

use Data::Dumper;
$Data::Dumper::Indent   = 1;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Purity   = 1;

use constant REFSUB   => ref sub { };
use constant REFHASH  => ref {};
use constant REFARRAY => ref [];

# Add signal handlers, load our config on start
BEGIN {
  $SIG{INT}  = \&CleanExit;
  $SIG{TERM} = \&CleanExit;
  $SIG{HUP}  = \&LoadConfig;
  $SIG{PIPE} = sub { };
}

my (
  $config,       $configfile,     $pause,          $noclean,   $host,
  $help,         %publicCommands, %defaultOptions, %cli,       %mapping,
  %commandParse, %commandText,    %menu,           $cliAction, @children,
);

# Looking for configs in all the right places
my @configtests;

use Config;
if ( $Config{osname} eq "haiku" ) {
  push( @configtests, "/boot/home/config/settings" );
}

if ( defined( $ENV{'HOME'} ) ) {
  push( @configtests, join( '/', ( $ENV{'HOME'}, qw(.tmuxc.conf) ) ) );
  push( @configtests, join( '/', ( $ENV{'HOME'}, qw(.config/tmuxc.conf) ) ) );
  push( @configtests, join( '/', ( $ENV{'HOME'}, qw(.config/tmuxc/tmuxc.conf) ) ) );
}

if ( defined( $ENV{'XDG_CONFIG_HOME'} ) ) {
  push( @configtests, join( '/', ( $ENV{'XDG_CONFIG_HOME'}, qw( tmuxc.settings) ) ) );
}

if ( scalar @configtests > 0 ) {
  foreach (@configtests) {
    if (-f) {
      $configfile = $_;
    }
  }
} else {
  print "Unable to find a configuration file\n";
  exit;
}

unless ( length $configfile ) {
  $configfile = $configtests[0];
}

$noclean = 1;
$pause   = 0;

# Manipulate ARGV before we got to our options parser
if ( ( scalar(@ARGV) == 1 ) and ( $ARGV[0] =~ m/@/ ) ) {

  # If we have a single argument, try to parse it as a session@host
  unshift( @ARGV, qw(-s) );
} elsif ( scalar(@ARGV) == 0 ) {

  # No arguments, show the help output
  unshift( @ARGV, qw(--help) );
}

GetOptions(
  "host|h=s"     => \$cli{host},
  "background|b" => \$cli{background},
  "config|c=s"   => \$configfile,
  "detach|d"     => \$cli{detach},
  "reconnect|R"  => \$cli{reconnect},
  "closeas|C"    => \$cli{closeas},
  "exitlast|E"   => \$cli{exitlast},
  "print|o"      => \$cli{printOptions},
  "wm|w=s"       => sub {
    ( undef, my $wm ) = @_;
    my @valid = ( "single", "multi" );
    unless ( grep { $_ eq $wm } @valid ) {
      print "Invalid window mode [" . join( ", ", @valid ) . "]: $wm";
      exit;
    } else {
      $cli{wm} = $wm;
    }
  },
  "verbose|v+" => sub {
    $cli{verbosity} += 1;
  },
  "poe|P=s" => sub {
    ( undef, my $scope ) = @_;
    my @valid = ( "none", "ephemeral", "any" );
    unless ( grep { $_ eq $scope } @valid ) {
      print "Invalid purge on exit scope [" . join( ", ", @valid ) . "]: $scope";
      exit;
    } else {
      $cli{poe} = $scope;
    }
  },
  "ephemeral|S" => sub {
    $cliAction = \&EphemeralSession;
  },
  "session|s=s" => sub {
    ( undef, my $session ) = @_;
    if ( $session =~ m/@/ ) {
      ( $cli{session}, $cli{host} ) = split( /@/, $session );
    } else {
      $cli{session} = $session;
    }
  },
  "new|n" => sub {
    $cliAction = sub {
      my $cmd         = "new-window -d";
      my $hostsession = SelectSession($cmd);
      InjectCommand( $cmd, $hostsession );
    };
  },
  "launcher|l" => sub {
    $cliAction = \&Launcher;
  },
  "known|k:s" => sub {
    ( undef, $cli{csv} ) = @_;
    $cliAction = sub {
      KnownSessions( $cli{csv} );
    };
  },
  "remote|K:s" => sub {
    ( undef, my $rhost ) = @_;
    $cliAction = sub {
      RemoteSessions($rhost);
    }
  },
  "menu|m" => sub {
    $cliAction = sub {
      Menu("paged");
    };
  },
  "singlemenu|M" => sub {
    $cliAction = sub {
      Menu("single");
    };
  },
  "exit|e" => sub {
    $cliAction = sub {
      my $cmd         = "tmuxc KillSelf";
      my $hostsession = SelectSession($cmd);
      InjectCommand( $cmd, $hostsession );
    };
  },
  "pause|p" => sub {
    $cliAction = sub {
      my $cmd         = "tmuxc PauseSelf";
      my $hostsession = SelectSession($cmd);
      InjectCommand( $cmd, $hostsession );
    },;
  },
  "raw|r=s" => sub {
    ( undef, $cli{raw} ) = @_;
    $cliAction = sub {
      my $hostsession = SelectSession( $cli{raw} );
      InjectCommand( $cli{raw}, $hostsession );
    };
  },
  "help|?" => sub {
    pod2usage( -verbose => 2 );
    exit;
  },
);

# Load our configuration file
LoadConfig;

# Set our log_level based on verbose flags, start logging
unless ( $config->{log_facility} eq '' ) {
  openlog( $RealScript, "nofatal,ndelay,pid", $config->{log_facility} );
  setlogmask( LOG_UPTO( $config->{log_level} ) );
}

Log( LOG_DEBUG, \$config );

# The last actionable option defined on the command line wins - execute it!
if ( ref $cliAction eq REFSUB ) {
  $cliAction->();
  exit;
}

# Check if an instance for this specific host and session is running
if ( -f $config->{pidfile} ) {
  open PID, '<', $config->{pidfile};
  my $pid = <PID>;
  close PID;
  if ( kill( 0, $pid ) ) {
    Log( LOG_DEBUG, "$config->{pidfile} exists, and is running" );
    die "$config->{pidfile} exists, and pid $pid is running\n";
  }
}

# Double fork
if ( $config->{background} ) {
  my $fpid = fork;
  exit if $fpid;    # kill first parent
  open STDIN,  '/dev/null';
  open STDOUT, '>/dev/null';
  open STDERR, '>/dev/null';
  setsid();
  $fpid = fork;
  exit if $fpid;
}

if ( $config->{log_level} == LOG_NOTICE ) {
  close STDERR;
}

$|++;

# Write our PID to a file, regardless of fg or bg state
open PID, '>', $config->{pidfile};
print PID $$;
close PID;

# Disable the noclean flag, now that we've written a PID to disk
$noclean = 0;

# Set our proc entry to tmuxc session@host
if ( $config->{prettyps} ) {
  $0 = sprintf( "%s %s@%s", $RealScript, $config->{session}, $config->{chost} );
}

Log( LOG_NOTICE, "running as PID $$" );

# Export our session name as an environment variable
my $session_env = join( '_', $config->{env_prefix}, "NAME" );
$ENV{$session_env} = $config->{session};

while (1) {

  %mapping = ();
  my @cmd;

  # pre-emptively kill any child processes we've previously tracked
  while (@children) {
    my $child = pop @children;
    Log( LOG_DEBUG, "Killing child process $child" );
    kill 'INT', $child;
    waitpid $child, 0;
  }

  my $chost = $config->{chost};
  my $sess  = $config->{session};

  # Remote host mode!
  # Check if we have a ControlMaster session, create it if not
  if ( defined($host) ) {

    if ( $config->{hosts}{$chost}{$sess}{ssh_prereqs} ) {
      foreach my $prereq ( @{ $config->{hosts}{$chost}{$sess}{ssh_prereqs} } ) {
        unless ( CheckSSHPrereqs( $host, [$prereq] ) ) {
          Log( LOG_DEBUG, "SSH prereq '$prereq' failed" );
          exit;
        }
      }
      Log( LOG_DEBUG, "SSH prereqs executed successfully" );
    }

    # Check if we have a ControlMaster session, create it if not
    unless ( CheckControlMaster($host) ) {

      # Master isn't running, start up a new ControlMaster
      my $failures = 0;
      my $backoff  = 1;
      while (1) {
        @cmd = buildCommand(
          undef,
          [
            qq(ssh),
            qq(-o ConnectTimeout=$config->{conn_timeout}),
            qq(-o ServerAliveInterval=$config->{alive_interval}),
            qq(-o ServerAliveCountMax=$config->{alive_count}),
            qq(-o ControlPersist=$config->{persist}),
            qq(-o ControlPath=$config->{temp}ssh/%C),
            qq(-o ControlMaster=yes),
            qq(@{ $config->{ssh_args} }),
            qq(-f -N),
            $host
          ]
        );
        Log( LOG_DEBUG, "ControlMaster for $host not running, creating one" );
        Log( LOG_DEBUG, join( ' ', @cmd ) );
        qx(@cmd);

        if ( ( $? >> 8 ) != 0 ) {
          unless ( $config->{reconnect} ) {
            Log( LOG_INFO, "Unable to connect to $host, reconnect is not enabled" );
            exit;
          }

          $failures += 1;
          Log( LOG_INFO, "Retrying connection to $host in $backoff seconds ($failures failures)" );
          sleep $backoff;

          # Exponential backoff up to 64 seconds
          unless ( $failures > 6 ) {
            $backoff = ( 1 * 2**$failures );
          }

        } else {

          # ControlMaster was successfully established
          Log( LOG_DEBUG, "ControlMaster session to $host established" );
          last;
        }
      }
    } else {

      # ControlMaster is already established
      Log( LOG_DEBUG, "Reusing ControlMaster session to $host" );
    }
  }

  my $initialize = $config->{hosts}{$chost}{$sess}{initialize}
    || [ qq(env $session_env=$config->{session}), $config->{tmux_bin}, qw(new-session -d -s), $sess ];
  $initialize = join( ' ', @{$initialize} );

  my $control = join( '/', $config->{chost}, $config->{control} );
  $control =~ s/\//-/g;

  my $script = join( '', ( $config->{temp}, $control ) );

  my $setup_script = qq|
exec 2>/dev/null

if ! $config->{tmux_bin} has-session -t $config->{session}; then
  $initialize
fi

if ! $config->{tmux_bin} has-session -t $config->{control}; then
  $config->{tmux_bin} new-session -d -t $config->{session} -s $config->{control}
fi

if VERSION="\$( $config->{tmux_bin} -V )"; then
  echo "\${VERSION}"
else
  echo "tmux unknown"
fi
|;

  open SCRIPT, '>', $script;
  print SCRIPT $setup_script;
  close SCRIPT;

  chmod 0700, $script;

  Log( LOG_DEBUG, "Created setup script: $script" );

  if ($host) {
    @cmd = buildCommand( $host, [qw(sh)] );
    push( @cmd, "< $script" );
  } else {
    @cmd = buildCommand( undef, [$script] );
  }

  my $setup_response = qx(@cmd);
  unlink $script;

  ( undef, $config->{version} ) = split( ' ', $setup_response );
  Log( LOG_DEBUG, "tmux version $config->{version} detected" );

  # Attach to control session in control mode
  @cmd = buildCommand( $host, [ $config->{tmux_bin}, qw(-C attach -t), $config->{control}, ] );
  Log( LOG_DEBUG, join( ' ', @cmd ) );

  my ( $pid, $child_out, $child_in );
  my $blockCapture = 0;
  my ( @block, $function, $result );

  $pid = open2( $child_out, $child_in, @cmd );
  Log( LOG_DEBUG, "Control session running as PID $pid" );
  push( @children, $pid );

  # Create our command channel
  unless ( -p $config->{command} ) {
    unlink $config->{command};
    mkfifo( $config->{command}, 0700 );
  }

  # Open it up non-blocking, read-only
  sysopen( CONTROL_FIFO, $config->{command}, O_NONBLOCK | O_RDONLY );

  # Install our USR1 handler to process anything in the FIFO
  $SIG{USR1} = sub {
    CONTROL_FIFO->clearerr;
    my @commands = <CONTROL_FIFO>;
    Log( LOG_DEBUG, "Processing commands in FIFO handler" );
    Log( LOG_DEBUG, \@commands );
    foreach my $line (@commands) {
      if ($pause) {
        next unless ( $line =~ m/tmuxc PauseSelf/ );
      }

      # Lines prefixed with tmuxc hit our internal command dispatcher
      if ( $line =~ m/^tmuxc\s(.*)/ ) {

        # The command causes tmux to print a block output, which we later parse
        if ( exists( $commandText{$1} ) ) {
          print $child_in $commandText{$1};
        } elsif ( exists( $publicCommands{$1} ) ) {

          # Execute a command directly with no required input
          $publicCommands{$1}->($child_in);
        } else {
          Log( LOG_INFO, "FIFO Handler: Unknown command $1" );
        }
      } else {

        # everything else is assumed to be a raw tmux command
        print $child_in "$line\n";
      }
    }
  };

  # Single Window Mode short-circuits the entire control mode processing loop

  if ( $config->{wm} eq "single" ) {
    spawnSingleTerm( $host, $config->{control}, $child_in );
  } else {

    # Commands sent to $child_in are not processed until the main loop.
    # The output of these commands will be read from $child_out and processed.
    #
    # Seed our initial list of windows
    print $child_in $commandText{'ListWindows'};

    # Detach any clients connected to windows
    if ( $config->{detach} ) {
      print $child_in $commandText{'BulkDetach'};
    }

    # Attach clients, force-regenerate a client map
    print $child_in $commandText{'BulkSpawn'};
    print $child_in $commandText{'ClientMap'};

    # Kick off a RefreshClient command to disable output if possible
    print $child_in $commandText{'RefreshClient'};

    # Main event loop - this processes lines sent over the control session
    while ( my $line = <$child_out> ) {
      next if $pause;
      next if $line =~ m/^\%output/;
      $line =~ s/\r\n/\n/g;
      Log( LOG_DEBUG, "$line" );

      # Trigger block capture mode
      if ( $line =~ m/^\%begin/ ) {
        $blockCapture = 1;
        next;
      }

      # Blocks can end with either end or error
      if ( $line =~ m/^\%end/ ) {
        $blockCapture = 0;
        next unless defined($function);
        Log( LOG_DEBUG, "Captured $function block" );

        my $cmd = $function;
        if ( exists( $commandParse{$cmd} ) ) {
          $commandParse{$cmd}->( \@block, $child_in );
        } else {
          Log( LOG_DEBUG, "No handler for $cmd" );
        }
        @block    = ();
        $function = undef;
        next;
      }

      # We messed up somewhere, reset the stack and carry on
      if ( $line =~ m/^\%error/ ) {
        Log( LOG_DEBUG, \@block );
        $blockCapture = 0;
        $function     = undef;
        @block        = ();
      }

      # Push the line to the current block
      if ($blockCapture) {
        ( $function, $result ) = split( /:/, $line );
        chomp($result);
        push @block, $result;
        next;
      }

      # This event produces a TON of spam
      # Linked sessions result in every session producing this, with out saying where it comes from
      # Multiple conditions are used to keep from spawning an infinite sequence of windows
      # %window-add @101
      if ( $line =~ m/^\%window-add\s(\@\d+)/ ) {
        if ( exists $mapping{windows}{$1}{'pending'} ) {

          # This is removed only by spawnTerm
          Log( LOG_DEBUG, "Skipping window-add: Session pending for $1" );
          next;
        } elsif ( defined $mapping{clients}{$1} ) {
          Log( LOG_DEBUG, "Skipping window-add: One or more clients attached to $1" );
          next;
        } elsif ( $mapping{windows}{$1}{'blacklisted'} ) {

          # When a window is added to a running session, we do not know the name of the window
          # blacklisting only works when initially connecting to a session
          Log( LOG_DEBUG, "Skipping window-add: $1 is blacklisted" );
          next;
        } elsif ( $mapping{windows}{$1}{ignore} ) {
          Log( LOG_DEBUG, "Skipping window-add: Ignore flag set for $1" );
          next;
        } else {
          $mapping{windows}{$1}{'pending'} = 1;
          print $child_in $commandText{'ListWindows'};
          Log( LOG_DEBUG, "window-add: Spawning a terminal for $1" );
          spawnTerm( $host, $sess, $1, $child_in );
          next;
        }
      }

      # Update our internal knowledge of the window name
      # %window-renamed @29 fish
      if ( $line =~ m/^\%window-renamed\s(@\d+)\s(.*)/ ) {
        Log( LOG_DEBUG, "Running $commandText{'ListWindows'}" );
        print $child_in $commandText{'ListWindows'};
        next;
      }

      # Update our client <> window map - two clients likely point to a single window
      # %session-window-changed $92 @115
      if ( $line =~ m/^\%session-window-changed\s(\$\d+)\s(\@\d+)/ ) {
        Log( LOG_DEBUG, "Running $commandText{'ClientMap'}" );
        print $child_in $commandText{'ClientMap'};
        next;
      }

      # Produced when a client attaches to a session,
      # %client-session-changed /dev/pts/10 $163 penthe-global-session-1545894242-319412-45
      if ( $line =~ m/^\%client-session-changed\s(.*)\s(\$\d+)\s([\w-]+)/ ) {
        Log( LOG_DEBUG, "Running $commandText{'ClientMap'}" );
        print $child_in $commandText{'ClientMap'};
        next;
      }

      # Produced when a client attaches or detaches (xterm is killed)
      # %sessions-changed
      if ( $line =~ m/^\%sessions-changed/ ) {
        Log( LOG_DEBUG, "Running $commandText{'ClientMap'}" );
        print $child_in $commandText{'ClientMap'};
        next;
      }

      # This event is fired once for each window in a session when a terminal (xterm, etc) is killed
      # Since it doesn't contain any other actionable values, it's unusable
      # %window-close @101
      if ( $line =~ m/^\%window-close\s(@\d+)/ ) {
        next;
      }

      # Produced when the process in a tmux window ends
      # Kill all attached sessions viewing that window
      # %unlinked-window-close @95
      if ( $line =~ m/^\%unlinked-window-close\s(@\d+)/ ) {

        # skip this if it doesn't exist in our mapping
        # it came from another session group
        next unless exists $mapping{clients}{$1};
        while ( @{ $mapping{clients}{$1} } ) {
          my $client = pop @{ $mapping{clients}{$1} };
          Log( LOG_DEBUG, "Killing session $client, window $1 closed" );
          print $child_in $commandText{'KillClient'} . "$client\n";
        }
        delete $mapping{clients}{$1};
        delete $mapping{windows}{$1};
        print $child_in $commandText{'ListWindows'};
        print $child_in $commandText{'ClientMap'};

      }
    }
  }

  if ( $config->{exitlast} ) {
    Log( LOG_DEBUG, "Control FIFO closed, checking if ControlMaster is still open" );
    if ( CheckControlMaster($host) ) {

      # If the ControlMaster session is still open, the tmux session has been closed - exit
      Log( LOG_DEBUG, "Exiting after last window in tmux session closed" );
      exit;
    }
  } else {
    exit unless ( $config->{reconnect} );
    Log( LOG_DEBUG, "ControlMaster has closed, attempting to reconnect" );
  }
}

END {
  exit if $noclean;

  if (
    ( exists $config->{poe} and $config->{poe} eq "any" )
    or (  ( exists $config->{ephemeral} and $config->{ephemeral} )
      and ( exists $config->{poe} and $config->{poe} eq "ephemeral" ) )
    )
  {
    my @cmd = buildCommand( $host, [ $config->{tmux_bin}, qw(kill-session -t), $config->{session}, ] );
    Log( LOG_DEBUG, "Killing session $config->{session}" );
    qx(@cmd);

    @cmd = buildCommand( $host, [ $config->{tmux_bin}, qw(kill-session -t), $config->{control}, ] );
    Log( LOG_DEBUG, "Killing control session $config->{control}" );
    qx(@cmd);
  }

  kill 'INT', @children if scalar(@children);
  CleanExit;
}

sub CleanExit {
  exit if $noclean;

  if ( exists $config->{command} ) {
    unlink $config->{command};
  }

  if ( exists $config->{pidfile} ) {
    unlink $config->{pidfile};
  }

  exit;
}

sub CheckSSHPrereqs {
  my $host = shift;

  my $ssh_prereqs = shift;

  my @cmd = buildCommand( undef, $ssh_prereqs );
  Log( LOG_DEBUG, "Executing connectivity test: " . join( ' ', @cmd ) );
  qx(@cmd);

  return ( $? >> 8 ) ? 0 : 1;
}

sub CheckControlMaster {
  my $host = shift;

  my @cmd = buildCommand(
    undef,
    [
      qq(ssh -q -O check),
      qq(-o ConnectTimeout=$config->{conn_timeout}),
      qq(-o ControlPath=$config->{temp}ssh/%C 2>/dev/null),
      $host
    ]
  );
  Log( LOG_DEBUG, "Checking ControlMaster for $host" );
  Log( LOG_DEBUG, join( ' ', @cmd ) );
  qx(@cmd);

  return ( $? >> 8 ) ? 0 : 1;
}

# Load our default config file / user defined
# Define other control values used throughout the multiverse
sub LoadConfig {
  undef $config;

  %defaultOptions = (
    "detach"         => 0,
    "reconnect"      => 1,
    "closeas"        => 0,
    "background"     => 0,
    "log_facility"   => "",
    "log_level"      => LOG_NOTICE,
    "exitlast"       => 0,
    "terminal"       => [qw(xterm)],
    "ssh_args"       => [qw()],
    "alive_interval" => 3,
    "alive_count"    => 2,
    "conn_timeout"   => 3,
    "persist"        => "10s",
    "selector"       => [qw(rofi -dmenu -i)],
    "input_prompt"   => [qw(rofi -dmenu -p)],
    "tmux_bin"       => "tmux",
    "env_prefix"     => "TMUX_SESSION",
    "temp"           => join( '/', ( $ENV{'HOME'}, qw(.tmuxc) ) ),
    "skipnw"         => 0,
    "prettyps"       => 1,
    "wm"             => "multi",
    "on_connect"     => [qw()],
    "poe"            => "none",
  );

  # Read in the config file
  if ( -e $configfile ) {
    $config = do($configfile) or die $!;
  }

  # strip a trailing slash if present, thanks Brian D Foy
  #$config->{temp} =~ s|/\z||;

  # Add a trailing slash, so joins are easier
  $config->{temp} =~ s|/*$|/|;

  # Set our hostname config key
  my $chost = defined( $cli{host} ) ? $cli{host} : "localhost";
  $config->{chost} = $chost;

  # Set our $host
  $host =
    ( defined( $cli{host} ) and ( $cli{host} ne "localhost" ) )
    ? $cli{host}
    : undef;

  # Determine which session name takes precedence
  if ( defined( $cli{session} ) ) {

    # Set on the command line
    $config->{session} = $cli{session};
  } elsif ( defined( $config->{hosts}{$chost} ) ) {

    # Pick the first session under this host, sorted, that is not a config key
    foreach my $key ( sort keys %{ $config->{hosts}{$chost} } ) {
      next if defined( $defaultOptions{$key} );
      $config->{session} = $key;
    }
  } elsif ( not defined( $config->{session} ) ) {

    # Not set at all in the config file, set a default
    $config->{session} = "global-session";
  }

  # '.' is forbidden in tmux session names
  $config->{session} =~ tr/\./-/;

  my $sess = $config->{session};

  # Record if this is an ephemeral session
  $config->{ephemeral} = ( defined( $config->{hosts}{$chost}{$sess} ) ) ? 0 : 1;

  # log level is a little tricky
  if ( defined( $cli{verbosity} ) ) {

    # I've got two -v's and a log debug
    if ( $cli{verbosity} > 2 ) {
      $cli{log_level} = LOG_DEBUG;
    } else {
      $cli{log_level} = $cli{verbosity} + LOG_NOTICE;
    }
  }

  # Look up a number of keys that can be set at different levels
  # If no value can be found, use a sane default
  foreach my $key ( keys %defaultOptions ) {
    if ( defined( $cli{$key} ) ) {

      # set on the CLI
      $config->{$key} = $cli{$key};
    } elsif ( defined( $config->{hosts}{$chost}{$sess}{$key} ) ) {

      # Set for a specific host/session combo
      $config->{$key} = $config->{hosts}{$chost}{$sess}{$key};
    } elsif ( defined( $config->{hosts}{$chost}{$key} ) ) {

      # Set for a specific host
      $config->{$key} = $config->{hosts}{$chost}{$key};
    } elsif ( defined( $config->{$key} ) ) {

      # Set globally in the config
      next;
    } else {

      # Not defined anywhere, set our fall-back default
      $config->{$key} = $defaultOptions{$key};
    }
  }

  # Make our temp directory and subdirectories
  mkdir $config->{temp} unless -d $config->{temp};
  my @subs = ( "ssh", "control", "pid" );
  foreach my $dir (@subs) {
    my $fulldir = join( '', $config->{temp}, $dir );
    mkdir $fulldir unless -d $fulldir;
  }

  # Set our hostname
  ( $config->{hostname}, undef ) = split( /\./, hostname, 2 );

  # Define our control session
  if ( $config->{wm} eq "single" ) {
    $config->{control} = join( '/', ( qw(tmuxc), $config->{hostname}, $config->{session} ) );
  } else {
    $config->{control} = join( '/', ( qw(tmuxc), $config->{session}, qw(control) ) );
  }

  # Define our command fifo
  $config->{command} =
    join( '', ( $config->{temp}, qw(control/), $config->{session}, qw(@), $config->{chost}, qw(.control) ) );

  # Define our PID file
  $config->{pidfile} = join( '', ( $config->{temp}, qw(pid/), $config->{session}, qw(@), $config->{chost}, qw(.pid) ) );

  %publicCommands = (
    'KillSelf'        => \&KillSelf,
    'PauseSelf'       => \&PauseSelf,
    'LoadConfig'      => \&LoadConfig,
    'ToggleEphemeral' => \&ToggleEphemeral,
  );

  # The first field in the format string indicates the lookup key for %commandParse
  %commandText = (
    'ListWindows' => "lsw -F 'ListWindows:#{session_group},#{window_id},#{window_name},#{window_index}' -t "
      . $config->{session} . "\n",
    'BulkSpawn'  => "lsc -F 'BulkSpawn:#{session_group},#{session_id},#{session_name},#{window_id}'\n",
    'BulkDetach' => "lsc -F 'BulkDetach:#{session_group},#{session_id},#{session_name},#{window_id}'\n",
    'ClientMap'  => "lsc -F 'ClientMap:#{session_group},#{session_id},#{session_name},#{window_id},#{window_name}'\n",
    'KillClient' => "kill-session -t ",
    'RefreshClient' => "lsc -F 'RefreshClient:#{client_name},#{session_group},#{session_name}'\n",
  );

  %commandParse = (
    'ListWindows'   => \&ListWindows,
    'BulkSpawn'     => \&BulkSpawn,
    'BulkDetach'    => \&BulkDetach,
    'ClientMap'     => \&ClientMap,
    'RefreshClient' => \&RefreshClient,
  );

  %menu = (
    'Create Ephemeral Session' => \&EphemeralSession,
    'Create New Window'        => 'new-window -d',
    'Detach Session Windows'   => 'tmuxc BulkDetach',
    'Kill Control Daemon'      => 'tmuxc KillSelf',
    'Open All Windows'         => 'tmuxc BulkSpawn',
    'Pause Session'            => 'tmuxc PauseSelf',
    'Reload Configuration'     => 'tmuxc LoadConfig',
    'Toggle Ephemeral'         => 'tmuxc ToggleEphemeral',
  );

  if ( defined( $cli{printOptions} ) ) {
    foreach my $key ( sort keys %{$config} ) {
      next if ( ref $config->{$key} eq REFHASH );
      my $ref = ref $config->{$key};
      if ( ref $config->{$key} eq REFARRAY ) {
        my $combined = join( ' ', @{ $config->{$key} } );
        print "$key: $combined\n";
      } else {
        print "$key: $config->{$key}\n";
      }
    }
    exit;
  }
}

# Simple command dispatcher, InjectCommand picks/prompts for the session
sub Menu {
  my $mode = shift;

  my ( $child_out, $child_in );
  my $pid = open2( $child_out, $child_in, @{ $config->{selector} } );

  if ( $mode eq "paged" ) {
    foreach my $item ( sort keys %menu ) {
      print $child_in "$item\n";
    }
  } elsif ( $mode eq "single" ) {
    my $instances = InstanceCheck();

    my @sessions;
    if ( defined( $instances->{running} ) ) {
      @sessions = @{ $instances->{running} };
    } else {
      exit;
    }

    # Put Create Ephemeral Session at the top
    foreach my $key ( sort keys %menu ) {
      next unless $key =~ m/Create Ephemeral Session/;
      print $child_in "$key\n";
    }
    for my $hostsession ( sort @sessions ) {
      foreach my $key ( sort keys %menu ) {

        # Add everything but Create Ephemeral Session
        next if $key =~ m/Create Ephemeral Session/;
        print $child_in "$hostsession ~ $key\n";
      }
    }
  }

  close($child_in);
  my $selection = <$child_out>;
  exit unless defined($selection);
  chomp($selection);

  my ( $hostsession, $action );

  # Single page action menu
  if ( $selection =~ m/\~/ ) {
    ( $hostsession, $action ) = split( /\ ~\ /, $selection );
    InjectCommand( $menu{$action}, $hostsession );
  } elsif ( ref $menu{$selection} eq REFSUB ) {

    # reference to a sub, just execute it
    $menu{$selection}->();
  } else {

    # Menu option to do an action on an unspecified session
    $hostsession = SelectSession( $menu{$selection} );
    InjectCommand( $menu{$selection}, $hostsession );
  }
}

sub EphemeralSession {
  my ( $child_out, $child_in, @prompt );
  @prompt = @{ $config->{input_prompt} };
  push( @prompt, "Session" );
  my $pid = open2( $child_out, $child_in, @prompt );

  print $child_in "";
  close($child_in);
  my $option = <$child_out>;
  exit unless defined($option);
  chomp($option);

  my ( $session, $host ) = split( /@/, $option, 2 );
  unless ( defined $host and length $host ) {
    $host = 'localhost';
  }

  LaunchNewInstance( join( '@', $session, $host ), "-E" );
  exit;
}

sub RemoteSessions {
  my $host = shift;

  my ( $child_out, $child_in, @prompt );

  # Prompt for a host if none were provided
  unless ( length($host) ) {
    my $pid = open2( $child_out, $child_in, @{ $config->{selector} } );
    print $child_in "Enter unlisted host name\n";
    foreach my $host ( sort keys %{ $config->{hosts} } ) {
      print $child_in "$host\n";
    }

    close($child_in);
    $host = <$child_out>;
    exit unless defined($host);
    chomp($host);

    if ( $host eq "Enter unlisted host name" ) {
      @prompt = @{ $config->{input_prompt} };
      push( @prompt, "Host" );
      $pid = open2( $child_out, $child_in, @prompt );

      print $child_in "";
      close($child_in);
      $host = <$child_out>;
      exit unless defined($host);
      chomp($host);
    }
  }

  my @cmd       = buildCommand( $host, [ $config->{tmux_bin}, qw(list-sessions) ] );
  my @rsessions = qx(@cmd);
  Log( LOG_DEBUG, \@rsessions );

  my $instances = InstanceCheck();

  my @ksessions;
  if ( defined( $instances->{running} ) ) {
    @ksessions = @{ $instances->{running} };
    Log( LOG_DEBUG, \@ksessions );
  }

  my $pid = open2( $child_out, $child_in, @{ $config->{selector} } );

  for my $hostsession ( sort @rsessions ) {
    chomp($hostsession);
    my ( $rsession, undef ) = split( /:/, $hostsession );
    next if ( $rsession =~ m/^tmuxc\// );
    $rsession = "$rsession\@$host";
    next if ( grep { $_ eq $rsession } @ksessions );
    Log( LOG_DEBUG, "Prompting for $rsession" );
    print $child_in "$rsession\n";
  }

  close($child_in);
  my $response = <$child_out>;
  exit unless defined($response);
  chomp($response);

  LaunchNewInstance( $response, "--poe none" );
  exit;
}

sub InstanceCheck {

  # Generate a list of instances from config file
  my ( @check, $instances );
  foreach my $host ( sort keys %{ $config->{hosts} } ) {
    foreach my $session ( sort keys %{ $config->{hosts}{$host} } ) {

      # Skip if this is an option name / reserved word
      next if defined( $defaultOptions{$session} );
      push @check, "$session\@$host";
    }
  }

  # Check each instance defined in config file
  for my $session (@check) {
    my $control =
      join( '', ( $config->{temp}, qw(control/), $session, ".control" ) );
    my $pidfile =
      join( '', ( $config->{temp}, qw(pid/), $session, ".pid" ) );
    if ( -f $pidfile ) {
      open PID, '<', $pidfile;
      my $pid = <PID>;
      close PID;

      my $running = kill( 0, $pid );
      if ($running) {
        Log( LOG_DEBUG, "Running session: $session" );
        push @{ $instances->{running} }, $session;
        $instances->{details}{$session}{pid}       = $pid;
        $instances->{details}{$session}{control}   = $control;
        $instances->{details}{$session}{ephemeral} = 0;
      } else {
        push @{ $instances->{dead} }, $session;
      }
    } else {
      push @{ $instances->{dead} }, $session;
    }
  }

  my $cglob    = join( '', ( $config->{temp}, qw(control/), "*.control" ) );
  my @controls = glob($cglob);

  for my $control (@controls) {
    my $session = basename($control);
    $session =~ s/\.control//;

    my $pidfile = $control;
    $pidfile =~ s/control/pid/g;

    if ( -f $pidfile ) {
      open PID, '<', $pidfile;
      my $pid = <PID>;
      close PID;

      my $running = kill( 0, $pid );
      if ($running) {
        unless ( grep { $_ eq $session } @{ $instances->{running} } ) {
          push @{ $instances->{running} }, $session;
          $instances->{details}{$session}{pid}       = $pid;
          $instances->{details}{$session}{control}   = $control;
          $instances->{details}{$session}{ephemeral} = 1;
        }
      } else {

        # If the pid isn't running, this is a one-off session that somehow lingered on
        # Remove the pidfile and the control socket
        unlink $pidfile;
        unlink $control;
      }
    } else {

      # No pidfile associated with this control socket, purge it
      unlink $control;
    }
  }
  return $instances;
}

sub KnownSessions {
  my $flag = shift;

  my $instances = InstanceCheck;

  if ( length($flag) ) {
    print "# state,session name,pid,control socket\n";
  }

  if ( defined( $instances->{running} ) ) {
    unless ( length($flag) ) {
      print "Active: \n";
    }
    for ( sort @{ $instances->{running} } ) {
      unless ( length($flag) ) {
        print "  $_";
        if ( $instances->{details}{$_}{ephemeral} ) {
          print " (ephemeral)\n";
        } else {
          print "\n";
        }
        print "    Control: " . $instances->{details}{$_}{control} . "\n";
        print "    PID: " . $instances->{details}{$_}{pid} . "\n";
      } else {
        print join( $flag, qw(active), $_, $instances->{details}{$_}{pid}, $instances->{details}{$_}{control} );
        print "\n";
      }
    }
  }
  if ( defined( $instances->{dead} ) ) {
    unless ( length($flag) ) {
      print "Inactive: \n";
    }
    for ( sort @{ $instances->{dead} } ) {
      unless ( length($flag) ) {
        print "  $_\n";
      } else {
        print join( $flag, qw(inactive), $_, '', '' );
        print "\n";
      }
    }
  }
  exit;
}

# Optionally requires a command, as this can influence the behavior
sub SelectSession {
  my $command = shift;

  my $instances = InstanceCheck;

  my @sessions;
  if ( defined( $instances->{running} ) ) {
    @sessions = @{ $instances->{running} };
  } else {
    exit;
  }
  my @sessmenu;

  # An exact host and session were provided
  if ( $cli{host} and $cli{session} ) {
    my $session = join( '', $cli{session}, qw(@), $cli{host} );
    if ( grep { $_ eq $session } @sessions ) {
      push @sessmenu, $session;
    }

    # Find all hosts that match what was provided on the CLI
  } elsif ( $cli{host} ) {
    for (@sessions) {
      if ( $_ =~ m/$cli{host}/ ) {
        push @sessmenu, $_;
      }
    }

    # Find all sessions that match what was provided on the CLi
  } elsif ( $cli{session} ) {
    for (@sessions) {
      if ( $_ =~ m/$cli{session}/ ) {
        push @sessmenu, $_;
      }
    }

    # Nothing provided, prompt with all running hosts/sessions
  } else {
    @sessmenu = @sessions;
  }

  # I really should learn splice some day
  if (  ( $command =~ m/new-window/ )
    and ( not defined( $cli{host} ) )
    and ( not defined( $cli{session} ) ) )
  {
    my @clean;
    for (@sessmenu) {
      my ( $sess, $host ) = split( '@', $_, 2 );
      unless ( $config->{hosts}{$host}{$sess}{skipnw} ) {
        push @clean, $_;
      }
    }
    @sessmenu = @clean;
  }

  # Generate a menu / or pick if there's only one session
  my ( $response, $session );
  if ( scalar(@sessmenu) > 1 ) {
    my ( $child_out, $child_in );
    my $pid = open2( $child_out, $child_in, @{ $config->{selector} } );

    for (@sessmenu) {
      my ( $sess, $host ) = split( '@', $_, 2 );
      print $child_in "$sess\@$host\n";
    }
    close($child_in);

    $session = <$child_out>;
    exit unless defined($session);
    chomp($session);
  } elsif ( scalar(@sessmenu) == 1 ) {
    $session = shift @sessmenu;
  } else {
    Log( LOG_NOTICE, "No running sessions" );
    exit;
  }
  Log( LOG_DEBUG, "Selected: $session" );
  return $session;
}

# Determine which control sessions are running, prompt for anything else
sub Launcher {
  my ( @dead, $child_out, $child_in );

  my $instances = InstanceCheck;

  if ( defined( $instances->{dead} ) ) {
    @dead = @{ $instances->{dead} };
  }

  my $response;
  if ( scalar(@dead) > 0 ) {
    my $pid = open2( $child_out, $child_in, @{ $config->{selector} } );
    for (@dead) {
      my ( $sess, $host ) = split( '@', $_, 2 );
      print $child_in "$sess\@$host\n";
      print $child_in "$sess\@$host (Single Window Mode)\n";
      print $child_in "$sess\@$host (Multi Window Mode)\n";
    }
    close($child_in);
    $response = <$child_out>;
    close($child_out);
  } else {
    exit;
  }
  exit unless defined($response);
  chomp($response);

  my $flags;
  if ( $response =~ m/Single Window Mode/ ) {
    ( $response, undef ) = split( ' ', $response );
    $flags = "--wm single";
  }
  if ( $response =~ m/Multi Window Mode/ ) {
    ( $response, undef ) = split( ' ', $response );
    $flags = "--wm multi";
  }

  LaunchNewInstance( $response, $flags );
}

# Do the double fork dance and launch a new tmuxc instance
sub LaunchNewInstance {
  my ( $session, $flags ) = @_;

  my ( $sess, $host ) = split( /@/, $session, 2 );
  my $myself = join( '/', ( $RealBin, $RealScript ) );

  $flags = "" unless ( defined $flags and length $flags );

  my $cmd;
  if ( $host eq "localhost" ) {
    $cmd = join( ' ', ( $myself, qw(-s), $sess, qw(-b), $flags ) );
  } else {
    $cmd = join( ' ', ( $myself, qw(-h), $host, qw(-s), $sess, qw(-b), $flags ) );
  }

  Log( LOG_DEBUG, "LaunchNewInstance: $cmd" );

  my $fpid = fork;
  if ( $fpid == 0 ) {
    exit 255 unless open STDIN,  '/dev/null';
    exit 255 unless open STDOUT, '>/dev/null';
    exit 255 unless open STDERR, '>/dev/null';
    setsid();
    $fpid = fork;
    if ( $fpid == 0 ) {
      $noclean = 0;
      exec($cmd);
    }
    $noclean = 1;
    exit;
  }
  waitpid( $fpid, 0 );
  $noclean = 1;
  exit;
}

# Given a session@host, inject a command into the FIFO and send a USR1 signal
sub InjectCommand {
  my ( $command, $session ) = @_;

  my $control =
    join( '', ( $config->{temp}, qw(control/), $session, ".control" ) );
  my $pidfile = join( '', ( $config->{temp}, qw(pid/), $session, ".pid" ) );

  Log( LOG_DEBUG, "PID file is $pidfile" );
  Log( LOG_DEBUG, "Control file is $control" );

  my $pid;
  if ( -f $pidfile ) {
    open PID, '<', $pidfile;
    $pid = <PID>;
    close PID;
  }

  unless ( kill( 0, $pid ) ) {
    print "$pid not running exiting!";
    unlink $pidfile;
    exit;
  }

  open CONTROL, '>', $control;
  print CONTROL "$command";
  close CONTROL;

  kill( 'USR1', $pid );
  exit;
}

sub shellQuote {
  my @return;

  for my $group (@_) {
    my @args = @$group;
    for (@args) {
      s/'/'"'"'/g;
    }
    push @return, join ' ', map { /^[-\/|@=_0-9a-z]+$/i ? $_ : qq{'$_'} } @args;
  }

  return join '|', @return;
}

# Wraps a given command with SSH when a remote host is defined
sub buildCommand {
  my $remote = shift;
  return @{ $_[0] } unless $remote;

  my $cpath = join( '', $config->{temp}, qw(ssh/%C) );
  my @cmd =
    grep { length } qw(ssh -q -t), @{ $config->{ssh_args} }, qw(-S), $cpath,
    $remote, shellQuote(@_);

  return @cmd;
}

sub spawnSingleTerm {
  my ( $host, $session, $child_in ) = @_;

  if ( length $config->{on_connect} ) {
    for my $option ( @{ $config->{on_connect} } ) {
      print Log( LOG_DEBUG, $option );
      print $child_in $option . "\n";
    }
  }

  my @cmd =
    buildCommand( $host, [ qq(env $session_env=$config->{session}), $config->{tmux_bin}, qw(attach -t), $session, ] );
  my $attach_command = join( ' ', @cmd );

  $session =~ s/\//-/g;
  my $script       = join( '', ( $config->{temp}, $session ) );
  my $start_script = qq|#!/bin/sh
test -f $script && rm $script
exec $attach_command
|;

  open SCRIPT, '>', $script;
  print SCRIPT $start_script;
  close SCRIPT;
  chmod 0700, $script;

  my @exec = @{ $config->{terminal} };
  push @exec, $script;
  Log( LOG_DEBUG, "Terminal spawn command" );
  Log( LOG_DEBUG, \@exec );
  my $fpid = fork;
  if ( $fpid == 0 ) {
    exit 255 unless open STDIN,  '/dev/null';
    exit 255 unless open STDOUT, '>/dev/null';
    exit 255 unless open STDERR, '>/dev/null';
    exec @exec;
  }
  push( @children, $fpid );
  waitpid( $fpid, 0 );
  pop(@children);
  return;
}

# Write out a custom shell script and launch it with our terminal
sub spawnTerm {
  my ( $host, $session, $window, $child_in ) = @_;
  my ( undef, $id ) = split( '@', $window );

  my $clone_session = join( '/', ( qw(tmuxc), $config->{hostname}, $session, $id ) );

  my $clone_command =
    join( ' ', ( qw(new-session -d -t), $session, qw(-s), $clone_session, qw(; select-window -t), $window, "\n" ) );
  print Log( LOG_DEBUG, $clone_command );
  print $child_in $clone_command;

  my @cmd = buildCommand( $host,
    [ qq(env $session_env=$config->{session}), $config->{tmux_bin}, qw(attach -t), $clone_session, ] );
  my $attach_command = join( ' ', @cmd );

  $clone_session =~ s/\//-/g;
  my $script       = join( '', ( $config->{temp}, $clone_session ) );
  my $start_script = qq|#!/bin/sh
test -f $script && rm $script
exec $attach_command
|;

  open SCRIPT, '>', $script;
  print SCRIPT $start_script;
  close SCRIPT;
  chmod 0700, $script;

  my @exec = @{ $config->{terminal} };
  push @exec, $script;
  Log( LOG_DEBUG, "Terminal spawn command" );
  Log( LOG_DEBUG, \@exec );
  my $fpid = fork;
  if ( $fpid == 0 ) {
    exit 255 unless open STDIN,  '/dev/null';
    exit 255 unless open STDOUT, '>/dev/null';
    exit 255 unless open STDERR, '>/dev/null';
    setsid();
    $fpid = fork;
    if ( $fpid == 0 ) {
      exec @exec;
    }
    $noclean = 1;
    exit;
  }
  waitpid( $fpid, 0 );
  return;
}

# Return 1 if blacklisted, 0 if not
sub checkIfBlacklisted {
  my $window = shift;
  Log( LOG_DEBUG, "Checking if $window is blacklisted on $config->{chost}" );

  my $chost = $config->{chost};
  my $sess  = $config->{session};

  if ( defined( $config->{hosts}{$chost}{$sess}{blacklist} ) ) {
    if ( grep { $_ eq $window } @{ $config->{hosts}{$chost}{$sess}{blacklist} } ) {
      Log( LOG_DEBUG, "Blacklisted window: $window" );
      return 1;
    }
  }
  return 0;
}

# List every window, set the blacklisted flag where appropriate
sub ListWindows {
  my $block = shift;
  for my $entry ( @{$block} ) {
    my ( $group, $id, $name, $wid ) = split( ',', $entry );
    $mapping{windows}{$id}{'name'}  = $name;
    $mapping{windows}{$id}{'index'} = $wid;
    $mapping{windows}{$id}{'blacklisted'} =
      ( checkIfBlacklisted($name) ) ? 1 : 0;
  }
  Log( LOG_DEBUG, "ListWindows end" );
  Log( LOG_DEBUG, \%mapping );
}

# Detach all clients from all windows, leaving everything else running
# This will NOT mark a window as ignored
sub BulkDetach {
  my $block    = shift;
  my $child_in = shift;

  Log( LOG_DEBUG, "BulkDetach start" );
  Log( LOG_DEBUG, \%mapping );

  for my $entry ( @{$block} ) {
    my ( $group, $sid, $name, $wid ) = split( ',', $entry );

    # Filter for our specific session group
    next unless $config->{session} eq $group;

    # Filter out our control session
    next if $config->{control} eq $name;

    Log( LOG_INFO, "Detaching terminal from $sid" );
    print $child_in $commandText{'KillClient'} . "$sid\n";
  }
}

# Spawn a terminal for all non-blacklisted windows
sub BulkSpawn {
  my $block    = shift;
  my $child_in = shift;

  Log( LOG_DEBUG, "BulkSpawn start" );
  Log( LOG_DEBUG, \%mapping );

  for my $entry ( @{$block} ) {
    my ( $group, $sid, $name, $wid ) = split( ',', $entry );

    # Filter for our specific session group
    next unless $config->{session} eq $group;

    # Filter out our control session
    next if $config->{control} eq $name;

    # Filter for our hostname in the linked session name
    next unless $name =~ m/$config->{hostname}/;

    # Don't push duplicate session ids
    unless ( grep { $_ eq $sid } @{ $mapping{clients}{$wid} } ) {
      push @{ $mapping{clients}{$wid} }, $sid;
    }
  }

  foreach my $window ( keys %{ $mapping{windows} } ) {
    if ( exists $mapping{clients}{$window} ) {
      next;
    } else {
      unless ( checkIfBlacklisted( $mapping{windows}{$window}{name} ) ) {
        Log( LOG_INFO, "Spawning a terminal for $window" );
        delete $mapping{clients}{$window};
        $mapping{windows}{$window}{'pending'} = 1;
        spawnTerm( $host, $config->{session}, $window, $child_in );
      }
    }
  }
  Log( LOG_DEBUG, "BulkSpawn end" );
  Log( LOG_DEBUG, \%mapping );
}

# This handler is used to set options for attached clients
# Currently it's a one-shot command that checks the tmux version to disable output on the control session
sub RefreshClient {
  my $block    = shift;
  my $child_in = shift;

  for my $entry ( @{$block} ) {
    my ( $cname, $group, $sname ) = split( ',', $entry );

    next unless $sname eq $config->{control};

    # tmux 3.0 introduced the no-output flag for control mode
    my ( $major, undef ) = split( '.', $config->{version} );
    if ( $major ge 3 ) {
      my $refresh = join( ' ', qw(refresh-client -t), $cname, qw(-F no-output) );
      Log( LOG_DEBUG, "Disabling output for control session" );
      Log( LOG_DEBUG, $refresh );
      print $child_in "$refresh\n";
    }

    last;
  }
}

# Build a map of all windows and the clients viewing the window
# If a client was viewing a window but has been closed, mark that window as ignored
# Future open-all commands will skip that window while the same tmuxc controller is running
sub ClientMap {
  my $block    = shift;
  my $child_in = shift;
  my $sess     = $config->{session};
  my @found_windows;

  Log( LOG_DEBUG, "ClientMap start" );
  Log( LOG_DEBUG, \%mapping );

  # Purge existing mappings
  my %previous = %mapping{clients};
  delete $mapping{clients};

  # Regenerate client <> window mappings
  for my $entry ( @{$block} ) {
    my ( $group, $sid, $name, $wid, $wname ) = split( ',', $entry );

    # Filter for our specific session group
    next unless $config->{session} eq $group;

    # Filter out our control session
    next if $config->{control} eq $name;

    # Filter for our hostname in the linked session name
    next unless $name =~ m/$config->{hostname}/;

    # This is a session we control, attached to a window
    push @{ $mapping{clients}{$wid} }, $sid;
    $mapping{windows}{$wid}{'name'} = $wname;

    # This is no longer pending, a session is pointed to it
    delete $mapping{windows}{$wid}{'pending'};
    push @found_windows, $wid;
  }

  # Ignore windows that were closed
  foreach my $window ( keys %{ $previous{clients} } ) {
    unless ( defined( $mapping{clients}{$window} ) ) {
      Log( LOG_INFO, "Setting ignore flag for $window" );
      $mapping{windows}{$window}{ignore} = 1;
    }
  }

  # Set options for newly attached windows
  # This should possibly be handled somewhere else?
  foreach my $client ( keys %{ $mapping{clients} } ) {
    unless ( defined( $previous{clients}{$client} ) ) {

      # It's critical that this be done AFTER a client has attached to a session
      # If it is done before, the session will be destroyed
      print $child_in "set-option -t $client destroy-unattached on\n";
      Log( LOG_DEBUG, "Setting destroy-unattached on for $client" );
    }
  }

  Log( LOG_DEBUG, "ClientMap end" );
  Log( LOG_DEBUG, \%mapping );

  if ( $config->{closeas} ) {
    my $close = 1;
    foreach my $win ( keys %{ $mapping{windows} } ) {
      next
        if ( defined $mapping{windows}{$win}{ignored}
        and $mapping{windows}{$win}{ignored} );
      next
        if ( defined $mapping{windows}{$win}{blacklisted}
        and $mapping{windows}{$win}{blacklisted} );
      next if ( defined $mapping{clients}{$win} );

      # We aren't done spawning windows, so don't exit yet
      $close = 0;
    }

    if ($close) {
      exit;
    }
  }
}

sub ToggleEphemeral {
  $config->{ephemeral} ^= 1;
  Log( LOG_DEBUG, "Ephemeral is now $config->{ephemeral}" );
}

sub PauseSelf {
  $pause ^= 1;
  Log( LOG_DEBUG, "Pause is now $pause" );
}

sub KillSelf {
  Log( LOG_DEBUG, "Received KillSelf command, killing $$" );
  kill 'INT', $$;
}

sub Log {
  my $level = shift;
  my $entry = shift;

  my ( $s, $m ) = gettimeofday;

  chomp($entry);
  if ( $level le $config->{log_level} ) {
    if ( $config->{log_level} == LOG_DEBUG ) {
      unless ( ref($entry) ) {
        syslog( $config->{log_level}, "%s", $entry );
        print STDERR "## $s.$m $entry\n";
      } else {
        print STDERR Dumper($entry);
      }
      return;
    } else {
      syslog( $config->{log_level}, "%s", $entry );
      print STDOUT "$entry\n";
      return;
    }
  }
}

__END__

=head1 NAME

B<tmuxc> - TMUX terminal manager

=head1 SYNOPSIS

B<tmuxc> [options]

=head1 OPTIONS

=over 4

=item B<--host|h>

Connect to a tmux instance on the listed host.

=item B<--session|s>

Attach to the listed tmux session, or attach to the session@hostname.

=item B<--background|b>

After connecting to a host and instance, background the daemon.

=item B<--config|c>

Use the specified configuration file, overriding the default location of F<~/.tmuxc.conf>.

=item B<--detach|d>

After connecting to a host and instance, detach any clients connected to the session.

=item B<--verbose|v>

Enable verbose/debugging mode to print extra details.

=item B<--reconnect|R>

Reconnect to a remote host via SSH if the connection drops. This is enabled by default. This option overrides a host/session specific disable flag.

=item B<--closeas|C>

Exit the control daemon after spawning terminals for every window.

=item B<--exitlast|E>

Exit the control daemon after the last windown in the tmux session is closed.

=item B<--new|n>

Create a new window for the specified tmux session on the specified host.

=item B<--launcher|l>

Open up a menu listing sessions from the .tmuxc.conf file that aren't running.

=item B<--menu|m>

Open up a menu listing control options. If one instance is running, the command is executed on that instance. If multiple are running, prompt the running sessions.

=item B<--poe|P>

Enable purge-on-exit for sessions of type 'none', 'ephemeral' or 'all'. This executes a I<kill-session> against the session on tmuxc exit.

=item B<--singlemenu|M>

Open up a menu listing control options. The options take the form of session@host ~ <action>, and are shown as a single-depth menu. Smart pagers (rofi, bemenu, etc) allow you to type partial words in any order to narrow down the option to execute.

=item B<--wm|w>

=over 2

=item B<single>

Enable single-window-mode. This opens up a single terminal for an entire tmux session, consistent with typical tmux usage.

=item B<multi>

Enable multi-window-mode. This opens up a terminal for each window in the tmux session. This is the default behavior.

=back

=item B<--known|k> | B<--known|k=,>

List active and inactive sessions. Takes an optional character argument to enable CSV output for machine parsing.

=item B<remote|K> | B<remote|K host>

List tmux sessions on a remote host that do not have a local instance of tmuxc attached to them, then connect to the session.

=item B<--print|o>

Print configuration options for the host and session selected from command line arguments.

=item B<--ephemeral|S>

Prompt for a new session. The session can take the form of B<session> or B<session@hostname>

=item B<--exit|e>

Tell a specified tmuxc instance to exit.

=item B<--pause|p>

Tell a specified tmuxc instance to toggle it's pause mode. When in pause mode, all tmux messages received are ignored, as are any commands sent to the FIFO or on the command line.

=item B<--raw|r>

Issue a raw tmux or tmuxc command to a specified instance.

=back

=head1 EXAMPLES

Connect to a session labeled I<global-session> on the host I<shellhost>, then background.

  tmuxc -h shellhost -s global-session -b

Connect to the default session on localhost, then background.

  tmuxc -b

Issue the raw tmux command I<new-window -d> to the default session on localhost.

  tmuxc -r 'new-window -d'

=head1 SCRIPTING

Each running instance of tmuxc creates a command FIFO that can be used to control tmux and tmuxc. The FIFO takes the form of F<hostname-session.control>, and by default is available in F<~/.tmuxc/control/>. Once you've written a command to the FIFO, send the B<USR1> signal to tmuxc. The PID is available in F<~/.tmuxc/pid/hostname-session.pid>.

See B<RAW COMMANDS> for examples.

=head1 RAW COMMANDS

Raw commands can take multiple forms. Commands prefaced with I<tmuxc> hit the internal
command dispatcher. Any other command is passed as-is to tmux. Most tmuxc commands are
of no real use to end-users.

=head2 EXAMPLES

  tmuxc PauseSelf
  new-window -d

=head2 TMUXC INTERNAL COMMANDS

=over 6

=item B<BulkSpawn>

Instruct tmuxc to spawn terminals for all windows that do not have an attached client.

=item B<BulkDetach>

Instruct tmuxc to close all clients attached to windows.

=item B<KillSelf>

Instruct tmuxc to cleanly exit.

=item B<PauseSelf>

Instruct tmuxc to ignore all input from the command line and from tmux, until this option is toggled again.

=item B<LoadConfig>

Instruct tmuxc to reload the configuration file from disk. The configuration file path discovered at the initial start of tmuxc is re-used.

=item B<ToggleEphemeral>

Flip the internal ephemeral flag for a running instance of tmuxc. This change is not persisted to the configuration file.

=back

=head1 AUTHOR

Zach Dykstra <dykstra.zachary@gmail.com>

=cut

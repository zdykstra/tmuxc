#!/usr/bin/env perl

use strict;
use warnings;

our $VERSION = '1.3.0';

use Getopt::Long qw(:config no_ignore_case auto_version);
use Time::HiRes qw( sleep gettimeofday );
use POSIX qw ( mkfifo setsid );
use FindBin qw ($RealScript $RealBin);
use Sys::Syslog qw(:standard :macros);
use Pod::Usage qw(pod2usage);
use File::Basename;
use Sys::Hostname;
use IPC::Open2;
use Fcntl;

use Data::Dumper;
$Data::Dumper::Indent   = 1;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Purity   = 1;

use constant REFSUB   => ref sub { };
use constant REFHASH  => ref {};
use constant REFARRAY => ref [];

# Forward declare all subs
sub LoadConfig;
sub InjectCommand;
sub shellQuote;
sub buildCommandRefArray;
sub buildCommand;
sub spawnTerm;
sub checkIfBlacklisted;
sub ListWindows;
sub BulkDetach;
sub BulkSpawn;
sub ClientMap;
sub RefreshClient;
sub CleanExit;
sub InstanceCheck;
sub KnownSessions;
sub SelectSession;
sub EphemeralSession;
sub Launcher;
sub LaunchNewInstance;
sub Menu;
sub SingleMenu;
sub PauseSelf;
sub KillSelf;
sub Log;

# Add signal handlers, load our config on start
BEGIN {
  $SIG{INT}  = \&CleanExit;
  $SIG{TERM} = \&CleanExit;
  $SIG{HUP}  = \&LoadConfig;
  $SIG{PIPE} = sub { };
}

my (
  $config,       $configfile,  $pause,          $v,              $noclean, $host,
  $help,         $passcount,   %publicCommands, %defaultOptions, %cli,     %mapping,
  %commandParse, %commandText, %menu,           $cliAction,
);

$configfile = join( '/', ( $ENV{'HOME'}, qw(.tmuxc.conf) ) );
$noclean    = 1;
$v          = LOG_NOTICE;
$pause      = 0;
$passcount  = 0;

GetOptions(
  "host|h=s"     => \$cli{host},
  "session|s=s"  => \$cli{session},
  "background|b" => \$cli{background},
  "config|c=s"   => \$configfile,
  "detach|d"     => \$cli{detach},
  "verbose|v+"   => \$v,
  "killrc|k"     => \$cli{killrc},
  "pauserc|P"    => \$cli{pauserc},
  "reconnect|R"  => \$cli{reconnect},
  "closeas|C"    => \$cli{closeas},
  "exitlast|E"   => \$cli{exitlast},
  "print|o"      => \$cli{printOptions},
  "ephemeral|S"  => sub {
    $cliAction = \&EphemeralSession;
  },
  "new|n" => sub {
    $cliAction = sub {
      my $cmd         = "new-window -d";
      my $hostsession = SelectSession($cmd);
      InjectCommand( $cmd, $hostsession );
    };
  },
  "launcher|l" => sub {
    $cliAction = \&Launcher;
  },
  "known|k:s" => sub {
    ( undef, $cli{csv} ) = @_;
    $cliAction = sub {
      KnownSessions( $cli{csv} );
    };
  },
  "menu|m" => sub {
    $cliAction = sub {
      Menu("paged");
    };
  },
  "singlemenu|M" => sub {
    $cliAction = sub {
      Menu("single");
    };
  },
  "exit|e" => sub {
    $cliAction = sub {
      my $cmd         = "tmuxc KillSelf";
      my $hostsession = SelectSession($cmd);
      InjectCommand( $cmd, $hostsession );
    };
  },
  "pause|p" => sub {
    $cliAction = sub {
      my $cmd         = "tmuxc PauseSelf";
      my $hostsession = SelectSession($cmd);
      InjectCommand( $cmd, $hostsession );
    },;
  },
  "raw|r=s" => sub {
    ( undef, $cli{raw} ) = @_;
    $cliAction = sub {
      my $hostsession = SelectSession( $cli{raw} );
      InjectCommand( $cli{raw}, $hostsession );
    };
  },
  "help|?" => sub {
    pod2usage( -verbose => 2 );
    exit;
  },
);
# Adjust our log level based on one or more -v's
$cli{log_level} = $v;

# Load our configuration file
LoadConfig;

# Set our log_level based on verbose flags, start logging
unless ( $config->{log_facility} eq '' ) {
  openlog( $RealScript, "nofatal,ndelay,pid", $config->{log_facility} );
  setlogmask( LOG_UPTO( $config->{log_level} ) );
}

Log( LOG_DEBUG, \$config );

# The last actionable option defined on the command line wins - execute it!
if ( ref $cliAction eq REFSUB ) {
  $cliAction->();
  exit;
}

# Check if an instance for this specific host and session is running
if ( -f $config->{pidfile} ) {
  open PID, '<', $config->{pidfile};
  my $pid = <PID>;
  close PID;
  if ( kill( 0, $pid ) ) {
    Log( LOG_DEBUG, "$config->{pidfile} exists, and is running" );
    die "$config->{pidfile} exists, and pid $pid is running\n";
  }
}

# Double fork
if ( $config->{background} ) {
  my $fpid = fork;
  exit if $fpid;    # kill first parent
  open STDIN,  '/dev/null';
  open STDOUT, '>/dev/null';
  open STDERR, '>/dev/null';
  setsid();
  $fpid = fork;
  exit if $fpid;
}

if ( $config->{log_level} == LOG_NOTICE ) {
  close STDERR;
}

$|++;

# Write our PID to a file, regardless of fg or bg state
open PID, '>', $config->{pidfile};
print PID $$;
close PID;

# Disable the noclean flag, now that we've written a PID to disk
$noclean = 0;

Log( LOG_NOTICE, "tmuxc running as PID $$" );

# Export our session name as an environment variable
my $session_env = join( '_', $config->{env_prefix}, "NAME" );
$ENV{$session_env} = $config->{session};

while (1) {

  %mapping = ();
  my @cmd;

  # Remote host mode!
  # Check if we have a ControlMaster session, create it if not
  if ( defined($host) ) {
    @cmd = buildCommand(
      undef,
      [
        qq(ssh -q -O check),
        qq(-o ConnectTimeout=$config->{conn_timeout}),
        qq(-o ControlPath=$config->{temp}ssh/%C 2>/dev/null),
        $host
      ]
    );
    Log( LOG_DEBUG, "Checking if ControlMaster for $host exists" );
    Log( LOG_DEBUG, join( ' ', @cmd ) );
    qx(@cmd);

    # Master isn't running, start up a new ControlMaster
    if ( ( $? >> 8 ) != 0 ) {
      @cmd = buildCommand(
        undef,
        [
          qq(ssh),
          qq(-o ConnectTimeout=$config->{conn_timeout}),
          qq(-o ServerAliveInterval=$config->{alive_interval}),
          qq(-o ServerAliveCountMax=$config->{alive_count}),
          qq(-o ControlPersist=$config->{persist}),
          qq(-o ControlPath=$config->{temp}ssh/%C),
          qq(-o ControlMaster=yes),
          qq(@{ $config->{ssh_args} }),
          qq(-f -N),
          $host
        ]
      );
      Log( LOG_DEBUG, "ControlMaster for $host not running, creating one" );
      Log( LOG_DEBUG, join( ' ', @cmd ) );
      qx(@cmd);

      if ( ( $? >> 8 ) != 0 ) {
        Log( LOG_INFO, "Retrying connection to $host in 5 seconds" );
        sleep 5;
        if ( $config->{reconnect} ) {
          goto MAINEND;
        }
      }
    }

    # Tell the remote instance to kill itself
    if ( $config->{killrc} ) {
      Log( LOG_INFO, "Killing remote tmuxc instance" );
      my $control = join( '-', qw(localhost), $config->{session} );
      @cmd = buildCommand( $cli{host}, [ qw(tmuxc -h localhost -s), $config->{session}, qw(-e) ] );
      Log( LOG_DEBUG, join( ' ', @cmd ) );
      qx(@cmd);

      # Tell the remote instance to pause itself
    } elsif ( $config->{pauserc} ) {
      Log( LOG_INFO, "Pausing remote tmuxc instance" );
      my $control = join( '-', qw(localhost), $config->{session} );
      @cmd = buildCommand( $cli{host}, [ qw(tmuxc -h localhost -s), $config->{session}, qw(-p) ] );
      Log( LOG_DEBUG, join( ' ', @cmd ) );
      qx(@cmd);
    }
  }

  # Check if session exists
  @cmd = buildCommand( $host, [ $config->{tmux_bin}, qw(has-session -t), $config->{session}, ] );
  Log( LOG_DEBUG, "Checking if session $config->{session} exists" );
  Log( LOG_DEBUG, join( ' ', @cmd ) );
  qx(@cmd);

  # If the session doesn't exist, use the user-defined method if it exists, else make a new empty one
  if ( ( $? >> 8 ) != 0 ) {

    # Second time through the loop and our session doesn't exist, so exit instead of creating a new session
    last if ( ( $config->{exitlast} ) and ($passcount) );

    my $chost      = $config->{chost};
    my $sess       = $config->{session};
    my $initialize = $config->{hosts}{$chost}{$sess}{initialize}
      || [ $config->{tmux_bin}, qw(new-session -d -s), $sess ];

    @cmd = buildCommand( $host, $initialize );
    Log( LOG_INFO,  "Initializing session: $sess" );
    Log( LOG_DEBUG, join( ' ', @cmd ) );
    qx(@cmd);

    if ( ( $? >> 8 ) != 0 ) {
      die "Session initilization failed, exiting";
    }
  }

  # Check if control session exists
  @cmd = buildCommand( $host, [ $config->{tmux_bin}, qw(has-session -t), $config->{control}, ] );
  qx(@cmd);

  if ( ( $? >> 8 ) == 0 ) {
    @cmd = buildCommand( $host, [ $config->{tmux_bin}, qw(kill-session -t), $config->{control}, ] );
    Log( LOG_DEBUG, "Killing existing control session" );
    Log( LOG_DEBUG, join( ' ', @cmd ) );
    qx(@cmd);
  }

  # Create control clone session
  @cmd = buildCommand( $host,
    [ $config->{tmux_bin}, qw(new-session -d -t), $config->{session}, qw(-s), $config->{control}, ] );
  Log( LOG_DEBUG, "Creating cloned session for control mode" );
  Log( LOG_DEBUG, join( ' ', @cmd ) );
  qx(@cmd);

  if ( ( $? >> 8 ) != 0 ) {
    die "Unable to create control session, exiting";
  }

  # Determine the version of tmux
  @cmd = buildCommand( $host, [ $config->{tmux_bin}, qw(-V), ] );
  my $version = qx(@cmd);
  ( undef, $config->{version} ) = split( ' ', $version );
  Log( LOG_DEBUG, "tmux version $config->{version} detected" );

  # Attach to control session in control mode
  @cmd = buildCommand( $host, [ $config->{tmux_bin}, qw(-C attach-session -t), $config->{control}, ] );

  my $sess = $config->{session};
  my ( $pid, $child_out, $child_in );
  my $blockCapture = 0;
  my ( @block, $function, $result );

  $pid = open2( $child_out, $child_in, @cmd );

  # Create our command channel
  unless ( -p $config->{command} ) {
    unlink $config->{command};
    mkfifo( $config->{command}, 0700 );
  }

  # Open it up non-blocking, read-only
  sysopen( CONTROL_FIFO, $config->{command}, O_NONBLOCK | O_RDONLY );

  # Install our USR1 handler to process anything in the FIFO
  $SIG{USR1} = sub {
    my @commands = <CONTROL_FIFO>;
    Log( LOG_DEBUG, "Processing commands in FIFO handler:" );
    Log( LOG_DEBUG, \@commands );
    foreach my $line (@commands) {
      if ($pause) {
        next unless ( $line =~ m/tmuxc PauseSelf/ );
      }

      # Lines prefixed with tmuxc hit our internal command dispatcher
      if ( $line =~ m/^tmuxc\s(.*)/ ) {

        # The command causes tmux to print a block output, which we later parse
        if ( exists( $commandText{$1} ) ) {
          print $child_in $commandText{$1};
        } elsif ( exists( $publicCommands{$1} ) ) {

          # Execute a command directly with no required input
          $publicCommands{$1}->();
        } else {
          Log( LOG_INFO, "FIFO Handler: Unknown command $1" );
        }
      } else {

        # everything else is assumed to be a raw tmux command
        print $child_in "$line\n";
      }
    }
  };

  # Commands sent to $child_in are not processed until the main loop.
  # The output of these commands will be read from $child_out and processed.

  # Seed our initial list of windows
  print $child_in $commandText{'ListWindows'};

  # Detach any clients connected to windows
  if ( $config->{detach} ) {
    print $child_in $commandText{'BulkDetach'};
  }

  # Attach clients, force-regenerate a client map
  print $child_in $commandText{'BulkSpawn'};
  print $child_in $commandText{'ClientMap'};

  # Kick off a RefreshClient command to disable output if possible
  print $child_in $commandText{'RefreshClient'};

  # Main event loop - this processes lines sent over the control session
  while ( my $line = <$child_out> ) {
    next if $pause;
    next if $line =~ m/^\%output/;
    $line =~ s/\r\n/\n/g;
    Log( LOG_DEBUG, "$line" );

    # Trigger block capture mode
    if ( $line =~ m/^\%begin/ ) {
      $blockCapture = 1;
      next;
    }

    # Blocks can end with either end or error
    if ( $line =~ m/^\%end/ ) {
      $blockCapture = 0;
      next unless defined($function);
      Log( LOG_DEBUG, "Captured $function block" );

      my $cmd = $function;
      if ( exists( $commandParse{$cmd} ) ) {
        $commandParse{$cmd}->( \@block, $child_in );
      } else {
        Log( LOG_DEBUG, "No handler for $cmd" );
      }
      @block    = ();
      $function = undef;
      next;
    }

    # Push the line to the current block
    if ($blockCapture) {
      ( $function, $result ) = split( /:/, $line );
      chomp($result);
      push @block, $result;
      next;
    }

    # This event produces a TON of spam
    # Linked sessions result in every session producing this, with out saying where it comes from
    # Multiple conditions are used to keep from spawning an infinite sequence of windows
    if ( $line =~ m/^\%window-add\s(\@\d+)/ ) {
      if ( exists $mapping{windows}{$1}{'pending'} ) {

        # This is removed only by spawnTerm
        Log( LOG_DEBUG, "Skipping window-add: Session pending for $1" );
        next;
      } elsif ( defined $mapping{clients}{$1} ) {
        Log( LOG_DEBUG, "Skipping window-add: One or more clients attached to $1" );
        next;
      } elsif ( $mapping{windows}{$1}{'blacklisted'} ) {

        # When a window is added to a running session, we do not know the name of the window
        # blacklisting only works when initially connecting to a session
        Log( LOG_DEBUG, "Skipping window-add: $1 is blacklisted" );
        next;
      } elsif ( $mapping{windows}{$1}{ignore} ) {
        Log( LOG_DEBUG, "Skipping window-add: Ignore flag set for $1" );
        next;
      } else {
        $mapping{windows}{$1}{'pending'} = 1;
        print $child_in $commandText{'ListWindows'};
        Log( LOG_DEBUG, "window-add: Spawning a terminal for $1" );
        spawnTerm( $host, $sess, $1 );
        next;
      }
    }

    # Update our internal knowledge of the window name
    # Currently not really useful ...
    if ( $line =~ m/^\%window-renamed\s(@\d+)\s(.*)/ ) {
      Log( LOG_DEBUG, "Running $commandText{'ListWindows'}" );
      print $child_in $commandText{'ListWindows'};
      next;
    }

    # Update our client <> window map - two clients likely point to a single window
    if ( $line =~ m/^\%session-window-changed\s(\$\d+)\s(\@\d+)/ ) {
      Log( LOG_DEBUG, "Running $commandText{'ClientMap'}" );
      print $child_in $commandText{'ClientMap'};
      next;
    }

    # Produced when a client attaches to a session,
    # %client-session-changed /dev/pts/10 $163 penthe-global-session-1545894242-319412-45
    # This is probably a useless event to process
    if ( $line =~ m/^\%client-session-changed\s(.*)\s(\$\d+)\s([\w-]+)/ ) {
      Log( LOG_DEBUG, "Running $commandText{'ClientMap'}" );
      print $child_in $commandText{'ClientMap'};
      next;
    }

    # Produced when a client attaches or detaches
    # This is probably a useless event to process
    if ( $line =~ m/^%sessions-changed/ ) {
      Log( LOG_DEBUG, "Running $commandText{'ClientMap'}" );
      print $child_in $commandText{'ClientMap'};
      next;
    }

    # Produced when a window is closed, e.g. exit from a shell
    # Kill all attached sessions viewing that window
    if ( $line =~ m/^%unlinked-window-close\s(@\d+)/ ) {
      next unless exists $mapping{clients}{$1};
      while ( @{ $mapping{clients}{$1} } ) {
        my $client = pop @{ $mapping{clients}{$1} };
        Log( LOG_DEBUG, "Killing session $client, window $1 close" );
        print $child_in $commandText{'KillClient'} . "$client\n";
      }
      delete $mapping{clients}{$1};
      delete $mapping{windows}{$1};
      print $child_in $commandText{'ListWindows'};
      print $child_in $commandText{'ClientMap'};

    }
  }
MAINEND:
  $passcount = 1;
  exit unless ( ( $config->{reconnect} ) or not( $config->{exitlast} ) );
}

END {
  exit if $noclean;
  CleanExit;
}

sub CleanExit {
  exit if $noclean;

  unlink $config->{command};
  unlink $config->{pidfile};
  exit;
}

# Load our default config file / user defined
# Define other control values used throughout the multiverse
sub LoadConfig {
  undef $config;

  %defaultOptions = (
    "detach"         => 0,
    "killrc"         => 0,
    "pauserc"        => 0,
    "reconnect"      => 1,
    "closeas"        => 0,
    "background"     => 0,
    "log_facility"   => "",
    "log_level"      => LOG_ALERT,
    "exitlast"       => 0,
    "terminal"       => [qw(xterm)],
    "ssh_args"       => [qw()],
    "alive_interval" => 3,
    "alive_count"    => 2,
    "conn_timeout"   => 3,
    "persist"        => "10s",
    "selector"       => [qw(rofi -dmenu -i)],
    "input_prompt"   => [qw(rofi -dmenu -p)],
    "tmux_bin"       => "tmux",
    "env_prefix"     => "TMUX_SESSION",
    "temp"           => join( '/', ( $ENV{'HOME'}, qw(.tmuxc) ) ),
  );

  # Read in the config file
  if ( -e $configfile ) {
    $config = do($configfile) or die $!;
  }

  # strip a trailing slash if present, thanks Brian D Foy
  #$config->{temp} =~ s|/\z||;

  # Add a trailing slash, so joins are easier
  $config->{temp} =~ s|/*$|/|;

  # Set our hostname config key
  my $chost = defined( $cli{host} ) ? $cli{host} : "localhost";
  $config->{chost} = $chost;

  # Set our $host
  $host =
    ( defined( $cli{host} ) and ( $cli{host} ne "localhost" ) )
    ? $cli{host}
    : undef;

  # Determine which session name takes precedence
  if ( defined( $cli{session} ) ) {

    # Set on the command line
    $config->{session} = $cli{session};
  } elsif ( defined( $config->{hosts}{$chost} ) ) {

    # Pick the first session under this host, sorted, that is not a config key
    foreach my $key ( sort keys %{ $config->{hosts}{$chost} } ) {
      next if defined( $defaultOptions{$key} );
      $config->{session} = $key;
    }
  } elsif ( not defined( $config->{session} ) ) {

    # Not set at all in the config file, set a default
    $config->{session} = "global-session";
  }

  my $sess = $config->{session};

  # Look up a number of keys that can be set at different levels
  # If no value can be found, use a sane default
  foreach my $key ( keys %defaultOptions ) {
    if ( defined( $cli{$key} ) ) {

      # set on the CLI
      $config->{$key} = $cli{$key};
    } elsif ( defined( $config->{hosts}{$chost}{$sess}{$key} ) ) {

      # Set for a specific host/session combo
      $config->{$key} = $config->{hosts}{$chost}{$sess}{$key};
    } elsif ( defined( $config->{hosts}{$chost}{$key} ) ) {

      # Set for a specific host
      $config->{$key} = $config->{hosts}{$chost}{$key};
    } elsif ( defined( $config->{$key} ) ) {

      # Set globally in the config
      next;
    } else {

      # Not defined anywhere, set our fall-back default
      $config->{$key} = $defaultOptions{$key};
    }
  }

  # Make our temp directory and subdirectories
  mkdir $config->{temp} unless -d $config->{temp};
  my @subs = ( "ssh", "control", "pid" );
  foreach my $dir (@subs) {
    my $fulldir = join( '', $config->{temp}, $dir );
    mkdir $fulldir unless -d $fulldir;
  }

  # Set our hostname
  ( $config->{hostname}, undef ) = split( /\./, hostname, 2 );

  # Define our control session
  $config->{control} = join( '-', ( $config->{hostname}, $config->{session}, qw(control) ) );

  # Define our command fifo
  $config->{command} =
    join( '', ( $config->{temp}, qw(control/), $config->{session}, qw(@), $config->{chost}, qw(.control) ) );

  # Define our PID file
  $config->{pidfile} = join( '', ( $config->{temp}, qw(pid/), $config->{session}, qw(@), $config->{chost}, qw(.pid) ) );

  %publicCommands = (
    'KillSelf'  => \&KillSelf,
    'PauseSelf' => \&PauseSelf,
  );

  # The first field in the format string indicates the lookup key for %commandParse
  %commandText = (
    'ListWindows' => "lsw -F 'ListWindows:#{session_group},#{window_id},#{window_name},#{window_index}' -t "
      . $config->{session} . "\n",
    'BulkSpawn'  => "lsc -F 'BulkSpawn:#{session_group},#{session_id},#{session_name},#{window_id}'\n",
    'BulkDetach' => "lsc -F 'BulkDetach:#{session_group},#{session_id},#{session_name},#{window_id}'\n",
    'ClientMap'  => "lsc -F 'ClientMap:#{session_group},#{session_id},#{session_name},#{window_id},#{window_name}'\n",
    'KillClient' => "kill-session -t ",
    'RefreshClient' => "lsc -F 'RefreshClient:#{client_name},#{session_group},#{session_name}'\n",
  );

  %commandParse = (
    'ListWindows'   => \&ListWindows,
    'BulkSpawn'     => \&BulkSpawn,
    'BulkDetach'    => \&BulkDetach,
    'ClientMap'     => \&ClientMap,
    'RefreshClient' => \&RefreshClient,
  );

  %menu = (
    'Create Ephemeral Session' => \&EphemeralSession,
    'Create New Window'        => 'new-window -d',
    'Detach Session Windows'   => 'tmuxc BulkDetach',
    'Kill Control Daemon'      => 'tmuxc KillSelf',
    'Open All Windows'         => 'tmuxc BulkSpawn',
  );

  if ( defined( $cli{printOptions} ) ) {
    foreach my $key ( sort keys %{$config} ) {
      next if ( ref $config->{$key} eq REFHASH );
      my $ref = ref $config->{$key};
      if ( ref $config->{$key} eq REFARRAY ) {
        my $combined = join( ' ', @{ $config->{$key} } );
        print "$key: $combined\n";
      } else {
        print "$key: $config->{$key}\n";
      }
    }
  }
}

# Simple command dispatcher, InjectCommand picks/prompts for the session
sub Menu {
  my $mode = shift;

  my ( $child_out, $child_in );
  my $pid = open2( $child_out, $child_in, @{ $config->{selector} } );

  if ( $mode eq "paged" ) {
    foreach my $item ( sort keys %menu ) {
      print $child_in "$item\n";
    }
  } elsif ( $mode eq "single" ) {
    my $instances = InstanceCheck;

    my @sessions;
    if ( defined( $instances->{running} ) ) {
      @sessions = @{ $instances->{running} };
    } else {
      exit;
    }

    # Put Create Ephemeral Session at the top
    foreach my $key ( sort keys %menu ) {
      next unless $key =~ m/Ephemeral/;
      print $child_in "$key\n";
    }
    for my $hostsession ( sort @sessions ) {
      foreach my $key ( sort keys %menu ) {

        # Add everything but Create Ephemeral Session
        next if $key =~ m/Ephemeral/;
        print $child_in "$hostsession \% $key\n";
      }
    }
  }

  close($child_in);
  my $selection = <$child_out>;
  exit unless defined($selection);
  chomp($selection);

  my ( $hostsession, $action );

  # Break apart single-page lines
  if ( $selection =~ m/\%/ ) {
    ( $hostsession, $action ) = split( /\ \%\ /, $selection );
  } else {

    # Record our action, invoke a session selector
    $action      = $selection;
    $hostsession = SelectSession( $menu{$action} );
  }

  # Check if it is a coderef and execute it
  # This is used when we don't need to run code in another instance
  if ( ref $menu{$action} eq REFSUB ) {
    $menu{$action}->();
  } else {
    InjectCommand( $menu{$action}, $hostsession );
  }
  exit;
}

sub EphemeralSession {
  my ( $child_out, $child_in, @prompt );
  @prompt = @{ $config->{input_prompt} };
  push( @prompt, "Session" );
  my $pid = open2( $child_out, $child_in, @prompt );

  print $child_in "";
  close($child_in);
  my $option = <$child_out>;
  exit unless defined($option);
  chomp($option);

  my ( $session, $host ) = split( /@/, $option, 2 );
  unless ( defined $host and length $host ) {
    $host = 'localhost';
  }

  LaunchNewInstance( join( '@', $session, $host ), "-E" );
  exit;
}

sub InstanceCheck {

  # Generate a list of instances from config file
  my ( @check, $instances );
  foreach my $host ( sort keys %{ $config->{hosts} } ) {
    foreach my $session ( sort keys %{ $config->{hosts}{$host} } ) {

      # Skip if this is an option name / reserved word
      next if defined( $defaultOptions{$session} );
      push @check, "$session\@$host";
    }
  }

  # Check each instance defined in config file
  for my $session (@check) {
    my $control =
      join( '', ( $config->{temp}, qw(control/), $session, ".control" ) );
    my $pidfile =
      join( '', ( $config->{temp}, qw(pid/), $session, ".pid" ) );
    if ( -f $pidfile ) {
      open PID, '<', $pidfile;
      my $pid = <PID>;
      close PID;

      my $running = kill( 0, $pid );
      if ($running) {
        Log( LOG_DEBUG, "Running session: $session" );
        push @{ $instances->{running} }, $session;
        $instances->{details}{$session}{pid}     = $pid;
        $instances->{details}{$session}{control} = $control;
      } else {
        push @{ $instances->{dead} }, $session;
      }
    } else {
      push @{ $instances->{dead} }, $session;
    }
  }

  my $cglob    = join( '', ( $config->{temp}, qw(control/), "*.control" ) );
  my @controls = glob($cglob);

  for my $control (@controls) {
    my $filename = basename($control);
    $filename =~ s/\.control//;

    my $pidfile = $control;
    $pidfile =~ s/control/pid/g;

    if ( -f $pidfile ) {
      open PID, '<', $pidfile;
      my $pid = <PID>;
      close PID;

      my $running = kill( 0, $pid );
      if ($running) {
        unless ( grep { $_ eq $filename } @{ $instances->{running} } ) {
          push @{ $instances->{running} }, $filename;
        }
      } else {

        # If the pid isn't running, this is a one-off session that somehow lingered on
        # Remove the pidfile and the control socket
        unlink $pidfile;
        unlink $control;
      }
    } else {

      # No pidfile associated with this control socket, purge it
      unlink $control;
    }
  }
  return $instances;
}

sub KnownSessions {
  my $flag = shift;

  my $instances = InstanceCheck;

  if ( defined( $instances->{running} ) ) {
    unless ( length($flag) ) {
      print "Active: \n";
    }
    for ( sort @{ $instances->{running} } ) {
      unless ( length($flag) ) {
        print "  $_\n";
        print "    Control: " . $instances->{details}{$_}{control} . "\n";
        print "    PID: " . $instances->{details}{$_}{pid} . "\n";
      } else {
        print join( $flag, qw(active), $_, $instances->{details}{$_}{pid}, $instances->{details}{$_}{control} );
        print "\n";
      }
    }
  }
  if ( defined( $instances->{dead} ) ) {
    if ( $flag eq "" ) {
      print "Inactive: \n";
    }
    for ( sort @{ $instances->{dead} } ) {
      if ( $flag eq "" ) {
        print "  $_\n";
      } else {
        print join( $flag, qw(inactive), $_ );
        print "\n";
      }
    }
  }
  exit;
}

# Optionally requires a command, as this can influence the behavior
sub SelectSession {
  my $command = shift;

  my $instances = InstanceCheck;

  my @sessions;
  if ( defined( $instances->{running} ) ) {
    @sessions = @{ $instances->{running} };
  } else {
    exit;
  }
  my @sessmenu;

  # An exact host and session were provided
  if ( $cli{host} and $cli{session} ) {
    my $session = join( '', $cli{session}, qw(@), $cli{host} );
    if ( grep { $_ eq $session } @sessions ) {
      push @sessmenu, $session;
    }

    # Find all hosts that match what was provided on the CLI
  } elsif ( $cli{host} ) {
    for (@sessions) {
      if ( $_ =~ m/$cli{host}/ ) {
        push @sessmenu, $_;
      }
    }

    # Find all sessions that match what was provided on the CLi
  } elsif ( $cli{session} ) {
    for (@sessions) {
      if ( $_ =~ m/$cli{session}/ ) {
        push @sessmenu, $_;
      }
    }

    # Nothing provided, prompt with all running hosts/sessions
  } else {
    @sessmenu = @sessions;
  }

  # I really should learn splice some day
  if (  ( $command =~ m/new-window/ )
    and ( not defined( $cli{host} ) )
    and ( not defined( $cli{session} ) ) )
  {
    my @clean;
    for (@sessmenu) {
      my ( $sess, $host ) = split( '@', $_, 2 );
      unless ( $config->{hosts}{$host}{$sess}{skipnw} ) {
        push @clean, $_;
      }
    }
    @sessmenu = @clean;
  }

  # Generate a menu / or pick if there's only one session
  my ( $response, $session );
  if ( scalar(@sessmenu) > 1 ) {
    my ( $child_out, $child_in );
    my $pid = open2( $child_out, $child_in, @{ $config->{selector} } );

    for (@sessmenu) {
      my ( $sess, $host ) = split( '@', $_, 2 );
      print $child_in "$sess\@$host\n";
    }
    close($child_in);

    $session = <$child_out>;
    exit unless defined($session);
    chomp($session);
  } elsif ( scalar(@sessmenu) == 1 ) {
    $session = shift @sessmenu;
  } else {
    Log( LOG_NOTICE, "No running sessions" );
    exit;
  }
  Log( LOG_DEBUG, "Selected: $session" );
  return $session;
}

# Determine which control sessions are running, prompt for anything else
sub Launcher {
  my ( @dead, $child_out, $child_in );

  my $instances = InstanceCheck;

  if ( defined( $instances->{dead} ) ) {
    @dead = @{ $instances->{dead} };
  }

  my $response;
  if ( scalar(@dead) > 0 ) {
    my $pid = open2( $child_out, $child_in, @{ $config->{selector} } );
    for (@dead) {
      my ( $sess, $host ) = split( '@', $_, 2 );
      print $child_in "$sess\@$host\n";
    }
    close($child_in);
    $response = <$child_out>;
    close($child_out);
  } else {
    exit;
  }
  exit unless defined($response);
  chomp($response);
  LaunchNewInstance($response);
}

# Do the double fork dance and launch a new tmuxc instance
sub LaunchNewInstance {
  my ( $session, $flags ) = @_;

  my ( $sess, $host ) = split( /@/, $session, 2 );
  my $myself = join( '/', ( $RealBin, $RealScript ) );

  $flags = "" unless ( defined $flags and length $flags );

  my $cmd;
  if ( $host eq "localhost" ) {
    $cmd = join( ' ', ( $myself, qw(-s), $sess, qw(-b), $flags ) );
  } else {
    $cmd = join( ' ', ( $myself, qw(-h), $host, qw(-s), $sess, qw(-b), $flags ) );
  }

  Log( LOG_DEBUG, "LaunchNewInstance: $cmd" );

  my $fpid = fork;
  if ( $fpid == 0 ) {
    exit 255 unless open STDIN,  '/dev/null';
    exit 255 unless open STDOUT, '>/dev/null';
    exit 255 unless open STDERR, '>/dev/null';
    setsid();
    $fpid = fork;
    if ( $fpid == 0 ) {
      $noclean = 0;
      exec($cmd);
    }
    $noclean = 1;
    exit;
  }
  waitpid( $fpid, 0 );
  $noclean = 1;
  exit;
}

# Given a session@host, inject a command into the FIFO and send a USR1 signal
sub InjectCommand {
  my ( $command, $session ) = @_;

  my $control =
    join( '', ( $config->{temp}, qw(control/), $session, ".control" ) );
  my $pidfile = join( '', ( $config->{temp}, qw(pid/), $session, ".pid" ) );

  Log( LOG_DEBUG, "PID file is $pidfile" );
  Log( LOG_DEBUG, "Control file is $control" );

  my $pid;
  if ( -f $pidfile ) {
    open PID, '<', $pidfile;
    $pid = <PID>;
    close PID;
  }

  unless ( kill( 0, $pid ) ) {
    print "$pid not running exiting!";
    unlink $pidfile;
    exit;
  }

  open CONTROL, '>', $control;
  print CONTROL "$command";
  close CONTROL;

  kill( 'USR1', $pid );
  exit;
}

sub shellQuote {
  my @return;

  for my $group (@_) {
    my @args = @$group;
    for (@args) {
      s/'/'"'"'/g;
    }
    push @return, join ' ', map { /^[-\/|@=_0-9a-z]+$/i ? $_ : qq{'$_'} } @args;
  }

  return join '|', @return;
}

# Wraps a given command with SSH when a remote host is defined
sub buildCommand {
  my $remote = shift;
  return @{ $_[0] } unless $remote;

  my $cpath = join( '', $config->{temp}, qw(ssh/%C) );
  my @cmd =
    grep { length } qw(ssh -q -t), @{ $config->{ssh_args} }, qw(-S), $cpath,
    $remote, shellQuote(@_);

  return @cmd;
}

# Write out a custom shell script and launch it with our terminal
sub spawnTerm {
  my ( $host, $session, $window ) = @_;
  my ( undef, $id )   = split( '@', $window );
  my ( $sec,  $usec ) = gettimeofday();
  my $clone_session = $config->{hostname} . "-$session-$sec-$usec-$id";

  my @cmd = buildCommand( $host, [ $config->{tmux_bin}, qw(new-session -d -t), $session, qw(-s), $clone_session, ] );
  my $clone_command = join( ' ', @cmd );

  @cmd = buildCommand(
    $host,
    [
      $config->{tmux_bin},     qw(attach-session -t),
      $clone_session,          qw(\; set-option destroy-unattached on),
      qw(\; select-window -t), $window,
    ]
  );
  my $attach_command = join( ' ', @cmd );

  my $script       = join( '', ( $config->{temp}, $clone_session ) );
  my $start_script = qq|#!/bin/sh
test -f $script && rm $script
$clone_command
exec $attach_command
|;

  open SCRIPT, '>', $script;
  print SCRIPT $start_script;
  close SCRIPT;
  chmod 0755, $script;

  my @exec = @{ $config->{terminal} };
  push @exec, $script;
  Log( LOG_DEBUG, "Terminal spawn command" );
  Log( LOG_DEBUG, \@exec );
  my $fpid = fork;
  if ( $fpid == 0 ) {
    exit 255 unless open STDIN,  '/dev/null';
    exit 255 unless open STDOUT, '>/dev/null';
    exit 255 unless open STDERR, '>/dev/null';
    setsid();
    $fpid = fork;
    if ( $fpid == 0 ) {
      exec @exec;
    }
    $noclean = 1;
    exit;
  }
  waitpid( $fpid, 0 );
  return;
}

# Return 1 if blacklisted, 0 if not
sub checkIfBlacklisted {
  my $window = shift;
  Log( LOG_DEBUG, "Checking if $window is blacklisted on $config->{chost}" );

  my $chost = $config->{chost};
  my $sess  = $config->{session};

  if ( defined( $config->{hosts}{$chost}{$sess}{blacklist} ) ) {
    if ( grep { $_ eq $window } @{ $config->{hosts}{$chost}{$sess}{blacklist} } ) {
      Log( LOG_DEBUG, "Blacklisted window: $window" );
      return 1;
    }
  }
  return 0;
}

# List every window, set the blacklisted flag where appropriate
sub ListWindows {
  my $block = shift;
  for my $entry ( @{$block} ) {
    my ( $group, $id, $name, $wid ) = split( ',', $entry );
    $mapping{windows}{$id}{'name'}  = $name;
    $mapping{windows}{$id}{'index'} = $wid;
    $mapping{windows}{$id}{'blacklisted'} =
      ( checkIfBlacklisted($name) ) ? 1 : 0;
  }
  Log( LOG_DEBUG, "ListWindows end" );
  Log( LOG_DEBUG, \%mapping );
}

# Detach all clients from all windows, leaving everything else running
# This will NOT mark a window as ignored
sub BulkDetach {
  my $block    = shift;
  my $child_in = shift;

  Log( LOG_DEBUG, "BulkDetach start" );
  Log( LOG_DEBUG, \%mapping );

  for my $entry ( @{$block} ) {
    my ( $group, $sid, $name, $wid ) = split( ',', $entry );

    # Filter for our specific session group
    next unless $config->{session} eq $group;

    # Filter out our control session
    next if $config->{control} eq $name;

    Log( LOG_INFO, "Detaching terminal from $sid" );
    print $child_in $commandText{'KillClient'} . "$sid\n";
  }
}

# Spawn a terminal for all non-blacklisted windows
sub BulkSpawn {
  my $block    = shift;
  my $child_in = shift;

  Log( LOG_DEBUG, "BulkSpawn start" );
  Log( LOG_DEBUG, \%mapping );

  for my $entry ( @{$block} ) {
    my ( $group, $sid, $name, $wid ) = split( ',', $entry );

    # Filter for our specific session group
    next unless $config->{session} eq $group;

    # Filter out our control session
    next if $config->{control} eq $name;

    # Filter for our hostname in the linked session name
    next unless $name =~ m/$config->{hostname}/;

    # Don't push duplicate session ids
    unless ( grep { $_ eq $sid } @{ $mapping{clients}{$wid} } ) {
      push @{ $mapping{clients}{$wid} }, $sid;
    }
  }

  foreach my $window ( keys %{ $mapping{windows} } ) {
    if ( exists $mapping{clients}{$window} ) {
      next;
    } else {
      unless ( checkIfBlacklisted( $mapping{windows}{$window}{name} ) ) {
        Log( LOG_INFO, "Spawning a terminal for $window" );
        delete $mapping{clients}{$window};
        $mapping{windows}{$window}{'pending'} = 1;
        spawnTerm( $host, $config->{session}, $window );
      }
    }
  }
  Log( LOG_DEBUG, "BulkSpawn end" );
  Log( LOG_DEBUG, \%mapping );
}

# This handler is used to set options for attached clients
# Currently it's a one-shot command that checks the tmux version to disable output on the control session
sub RefreshClient {
  my $block    = shift;
  my $child_in = shift;

  for my $entry ( @{$block} ) {
    my ( $cname, $group, $sname ) = split( ',', $entry );

    next unless $sname eq $config->{control};

    # tmux 3.0 introduced the no-output flag for control mode
    if ( int( $config->{version} ) ge 3 ) {
      my $refresh = join( ' ', qw(refresh-client -t), $cname, qw(-F no-output) );
      Log( LOG_DEBUG, "Disabling output for control session" );
      Log( LOG_DEBUG, $refresh );
      print $child_in "$refresh\n";
    }

    last;
  }
}

# Build a map of all windows and the clients viewing the window
# If a client was viewing a window but has been closed, mark that window as ignored
# Future open-all commands will skip that window while the same tmuxc controller is running
sub ClientMap {
  my $block    = shift;
  my $child_in = shift;
  my $sess     = $config->{session};
  my @found_windows;

  Log( LOG_DEBUG, "ClientMap start" );
  Log( LOG_DEBUG, \%mapping );

  # Purge existing mappings
  my %previous = %mapping{clients};
  delete $mapping{clients};

  # Regenerate client <> window mappings
  for my $entry ( @{$block} ) {
    my ( $group, $sid, $name, $wid, $wname ) = split( ',', $entry );

    # Filter for our specific session group
    next unless $config->{session} eq $group;

    # Filter out our control session
    next if $config->{control} eq $name;

    # Filter for our hostname in the linked session name
    next unless $name =~ m/$config->{hostname}/;

    # This is a session we control, attached to a window
    push @{ $mapping{clients}{$wid} }, $sid;
    $mapping{windows}{$wid}{'name'} = $wname;

    # This is no longer pending, a session is pointed to it
    delete $mapping{windows}{$wid}{'pending'};
    push @found_windows, $wid;
  }

  foreach my $window ( keys %{ $previous{clients} } ) {
    unless ( defined( $mapping{clients}{$window} ) ) {
      Log( LOG_INFO, "Setting ignore flag for $window" );
      $mapping{windows}{$window}{ignore} = 1;
    }
  }

  Log( LOG_DEBUG, "ClientMap end" );
  Log( LOG_DEBUG, \%mapping );

  if ( $config->{closeas} ) {
    my $close = 1;
    foreach my $win ( keys %{ $mapping{windows} } ) {
      next
        if ( defined $mapping{windows}{$win}{ignored}
        and $mapping{windows}{$win}{ignored} );
      next
        if ( defined $mapping{windows}{$win}{blacklisted}
        and $mapping{windows}{$win}{blacklisted} );
      next if ( defined $mapping{clients}{$win} );

      # We aren't done spawning windows, so don't exit yet
      $close = 0;
    }

    if ($close) {
      exit;
    }
  }
}

sub PauseSelf {
  $pause ^= 1;
}

sub KillSelf {
  exit;
}

sub Log {
  my $level = shift;
  my $entry = shift;

  my ( $s, $m ) = gettimeofday;

  chomp($entry);
  if ( $level le $config->{log_level} ) {
    if ( $config->{log_level} == LOG_DEBUG ) {
      unless ( ref($entry) ) {
        syslog( $config->{log_level}, "%s", $entry );
        print STDERR "## $s.$m $entry\n";
      } else {
        print STDERR Dumper($entry);
      }
      return;
    } else {
      syslog( $config->{log_level}, "%s", $entry );
      print STDOUT "$entry\n";
      return;
    }
  }
}

__END__

=head1 NAME

B<tmuxc> - TMUX terminal manager

=head1 SYNOPSIS

B<tmuxc> [options]

=head1 OPTIONS

=over 4

=item B<--host|h>

Connect to a tmux instance on the listed host.

=item B<--session|s>

Attach to the listed tmux session.

=item B<--background|b>

After connecting to a host and instance, background the daemon.

=item B<--config|c>

Use the specified configuration file, overriding the default location of F<~/.tmuxc.conf>.

=item B<--detach|d>

After connecting to a host and instance, detach any clients connected to the session.

=item B<--verbose|v>

Enable verbose/debugging mode to print extra details.

=item B<--killrc|k>

After connecting to a remote host, kill the remote tmuxc instance monitoring our session.

=item B<--reconnect|R>

Reconnect to a remote host via SSH if the connection drops. This is enabled by default. This option overrides a host/session specific disable flag.

=item B<--closeas|C>

Exit the control daemon after spawning terminals for every window.

=item B<--exitlast|E>

Exit the control daemon after the last windown in the tmux session is closed.

=item B<--new|n>

Create a new window for the specified tmux session on the specified host.

=item B<--launcher|l>

Open up a menu listing sessions from the .tmuxc.conf file that aren't running.

=item B<--menu|m>

Open up a menu listing control options. If one instance is running, the command is executed on that instance. If multiple are running, prompt the running sessions.

=item B<--known|k> | B<--known|k=,>

List active and inactive sessions. Takes an optional character argument to enable CSV output for machine parsing.

=item B<--print|o>

Print configuration options for the host and session selected from command line arguments.

=item B<--oneoff|S>

Prompt for a new session. The session can take the form of B<session> or B<session@hostname>

=item B<--exit|e>

Tell a specified tmuxc instance to exit.

=item B<--pause|p>

Tell a specified tmuxc instance to toggle it's pause mode. When in pause mode, all tmux messages received are ignored, as are any commands sent to the FIFO or on the command line.

=item B<--raw|r>

Issue a raw tmux or tmuxc command to a specified instance.

=back

=head1 EXAMPLES

Connect to a session labeled I<global-session> on the host I<shellhost>, then background.

  tmuxc -h shellhost -s global-session -b

Connect to the default session on localhost, then background.

  tmuxc -b

Issue the raw tmux command I<new-window -d> to the default session on localhost.

  tmuxc -r 'new-window -d'

=head1 SCRIPTING

Each running instance of tmuxc creates a command FIFO that can be used to control tmux and tmuxc. The FIFO takes the form of F<hostname-session.control>, and by default is available in F<~/.tmuxc/control/>. Once you've written a command to the FIFO, send the B<USR1> signal to tmuxc. The PID is available in F<~/.tmuxc/pid/hostname-session.pid>. 

See B<RAW COMMANDS> for examples. 

=head1 RAW COMMANDS

Raw commands can take multiple forms. Commands prefaced with I<tmuxc> hit the internal
command dispatcher. Any other command is passed as-is to tmux. Most tmuxc commands are
of no real use to end-users.

=head2 EXAMPLES

  tmuxc PauseSelf
  new-window -d

=head2 TMUXC INTERNAL COMMANDS

=over 6

=item B<BulkSpawn>

Instruct tmuxc to spawn terminals for all windows that do not have an attached client.

=item B<BulkDetach>

Instruct tmuxc to close all clients attached to windows.

=item B<KillSelf>

Instruct tmuxc to cleanly exit.

=item B<PauseSelf>

Instruct tmuxc to ignore all input from the command line and from tmux, until this 
option is toggled again.

=back

=head1 AUTHOR

Zach Dykstra <dykstra.zachary@gmail.com>

=cut
